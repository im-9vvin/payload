---
title: 자체 플러그인 구축하기
label: 자체 플러그인 구축
order: 20
desc: 자체 플러그인 구축을 시작하시나요? 필요한 모든 것을 찾고 Payload 플러그인 템플릿으로 모범 사례를 배우세요.
keywords: plugins, template, config, configuration, extensions, custom, documentation, Content Management System, cms, headless, javascript, node, react, nextjs
---

자체 [Payload 플러그인](./overview) 구축은 쉽고, Payload에 이미 익숙하다면 시작하는 데 필요한 모든 것을 갖추고 있습니다. 처음부터 시작하거나 [플러그인 템플릿](#플러그인-템플릿)을 사용하여 빠르게 시작할 수 있습니다.

<Banner type="success">
  템플릿을 사용하려면 터미널에서 직접 `npx create-payload-app@latest --template plugin`을
  실행하세요.
</Banner>

저희 플러그인 템플릿은 전체 생명주기 플러그인을 구축하는 데 필요한 모든 것을 포함합니다:

- Payload 구성 확장을 위한 예시 파일 및 함수
- 플러그인 개발을 위한 로컬 개발 환경
- 통합된 GitHub 워크플로우가 포함된 테스트 스위트

코드를 플러그인으로 추상화하면 여러 프로젝트에서 기능을 재사용할 수 있고 다른 개발자들이 사용할 수 있도록 만들 수 있습니다.

## 플러그인 요약

다음은 Payload와 플러그인을 통합하는 방법에 대한 간략한 요약입니다. 자세히 알아보려면 [플러그인 개요 페이지](https://payloadcms.com/docs/plugins/overview)로 돌아가세요.

### 플러그인 설치 방법

플러그인을 설치하려면 Payload 구성의 plugins 배열에 추가하기만 하면 됩니다.

```
import samplePlugin from 'sample-plugin';

const config = buildConfig({
  plugins: [
    // 여기에 플러그인 추가
    samplePlugin({
		enabled: true,
    }),
  ],
});

export default config;
```

### 초기화

초기화 프로세스는 다음 순서로 진행됩니다:

1. 들어오는 구성이 검증됩니다
2. 플러그인이 실행됩니다
3. 기본 옵션이 통합됩니다
4. 정제(sanitization)가 데이터를 정리하고 검증합니다
5. 최종 구성이 초기화됩니다

## 플러그인 템플릿

[Payload 플러그인 템플릿](https://github.com/payloadcms/payload/tree/main/templates/plugin)에서 플러그인 전반에서 사용되는 공통 파일 구조를 볼 수 있습니다:

1. `/` 루트 폴더 - 일반 구성
2. `/src` 폴더 - 플러그인과 관련된 모든 것
3. `/dev` 폴더 - 개발을 위한 정제된 테스트 프로젝트

### 루트 폴더

루트 폴더에서 플러그인 구성과 관련된 다양한 파일들을 볼 수 있습니다. Payload 코어와 다른 프로젝트에서 비슷한 방식으로 환경을 설정합니다. 수정해야 할 파일은 두 개뿐입니다:

- **README**.md - 템플릿 사용 방법에 대한 지침이 포함되어 있습니다. 준비가 되면 플러그인 사용 방법에 대한 지침을 포함하도록 업데이트하세요.
- **package**.json - 필요한 스크립트와 의존성을 포함합니다. 이 파일의 메타데이터를 덮어써서 플러그인을 설명하세요.

### dev 폴더

**dev** 폴더의 목적은 정제된 로컬 Payload 프로젝트를 제공하는 것입니다. 활발히 개발 중인 동안 플러그인을 실행하고 테스트할 수 있습니다.

이 폴더에 플러그인 기능을 저장하지 **마세요** - 이는 순수하게 플러그인 개발을 _돕기_ 위한 환경입니다.

처음부터 시작하는 경우, 다음과 같이 쉽게 개발 환경을 설정할 수 있습니다:

```
mkdir dev
cd dev
npx create-payload-app@latest
```

플러그인 템플릿을 사용하는 경우, dev 폴더가 구축되어 있고 `samplePlugin`이 이미 `dev/payload.config.ts`에 설치되어 있습니다.

```
  plugins: [
    // 플러그인을 이름을 바꾸거나 옵션을 추가할 때는 여기서 업데이트하세요
    samplePlugin({
      enabled: false,
    })
  ]
```

플러그인을 테스트하기 위해 필요에 따라 `dev/payload.config.ts`에 추가하고 개발 프로젝트를 구축할 수 있습니다.

개발을 시작할 준비가 되면, `cd dev`로 이 폴더로 이동하세요.

그런 다음 `pnpm dev`로 프로젝트를 시작하고 브라우저에서 `http://localhost:3000`을 여세요.## 테스팅

dev 폴더의 또 다른 이점은 테스트를 위한 완벽한 환경이 구축되어 있다는 것입니다.

좋은 테스트 스위트는 플러그인의 품질과 안정성을 보장하는 데 필수적입니다. Payload는 일반적으로 [Jest](https://jestjs.io/)를 사용합니다; React로 구축된 애플리케이션에 특히 널리 사용되는 JavaScript 테스트를 위한 인기 있는 테스트 프레임워크입니다.

Jest는 테스트를 테스트 스위트와 케이스로 구성합니다. 플러그인의 처음부터 끝까지 예상되는 동작을 기반으로 테스트를 생성하는 것을 권장합니다. [Jest 문서](https://jestjs.io/)에서 테스트에 대해 자세히 읽어보세요.

플러그인 템플릿은 `dev/plugin.spec.ts`에 준비된 테스트 스위트를 제공합니다. 자체 테스트 조건을 추가하기만 하면 모든 준비가 완료됩니다!

```
let payload: Payload

describe('Plugin tests', () => {
  // 시드 데이터를 확인하는 예시 테스트
  it('seeds data accordingly', async () => {
    const newCollectionQuery = await payload.find({
      collection: 'newCollection',
      sort: 'createdAt',
    })

    newCollection = newCollectionQuery.docs

    expect(newCollectionQuery.totalDocs).toEqual(1)
  })
})
```

## 데이터 시드하기

개발과 테스트를 위해서는 작업할 데이터가 필요할 것입니다. 수동으로 데이터를 입력하는 대신 데이터베이스를 시드하고 삭제하여 이 프로세스를 간소화할 수 있습니다.

플러그인 템플릿에서 `dev/src/server.ts`로 이동하면 예시 시드 함수를 볼 수 있습니다.

```
if (process.env.PAYLOAD_SEED === 'true') {
    await seed(payload)
}
```

샘플 시드 함수가 `dev/src/seed`에 생성되었습니다. 필요에 따라 추가 데이터로 이 파일을 업데이트하세요.

```
export const seed = async (payload: Payload): Promise<void> => {
  payload.logger.info('Seeding data...')

  await payload.create({
    collection: 'new-collection',
    data: {
      title: 'Seeded title',
    },
  })

  // 여기에 추가 시드 데이터를 추가하세요
}

```

## 플러그인 구축하기

이제 환경 설정과 개발 프로젝트 준비가 완료되었으니 - 플러그인을 구축할 시간입니다!

```
import type { Config } from 'payload'

export const samplePlugin =
  (pluginOptions: PluginTypes) =>
  (incomingConfig: Config): Config => {
    // 들어오는 구성의 복사본 생성
    let config = { ...incomingConfig }

    /**
    * 여기서 플러그인 옵션을 기반으로
    * 구성을 수정할 수 있습니다
    */

    // 새 컬렉션을 추가하려면:
    config.collections = [
      ...(config.collections || []),
      newCollection,
    ]

    // 새 글로벌을 추가하려면:
    config.globals = [
      ...(config.globals || []),
      newGlobal,
    ]

    /**
    * 컬렉션에 새 필드를 추가하려면:
    *
    * 1. 컬렉션을 순회
    * 2. 필드를 추가하려는 컬렉션 찾기
    * 3. 컬렉션에 필드 추가
    */

    // onInit에 추가하려면:
    config.onInit = async payload => {
      if (incomingConfig.onInit) await incomingConfig.onInit(payload)
      // 여기에 추가 onInit 코드 추가
    }

    // 마지막으로 수정된 구성을 반환
    return config
 }
```

다시 말하자면, [Payload 플러그인](./overview)의 본질은 단순히 [Payload 구성](../configuration/overview)을 확장하는 것이며 - 이것이 정확히 이 파일에서 하고 있는 것입니다.

### 전개 구문

[전개 구문](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) (또는 전개 연산자)은 점 표기법 **(...)** 을 사용하여 배열, 문자열 또는 객체의 요소를 다양한 컨텍스트로 전개하는 JavaScript의 기능입니다.

기존 데이터를 잃지 않고 기존 배열에 데이터를 추가할 수 있도록 전개 구문을 사용할 것입니다. 기존 데이터를 올바르게 전개하는 것이 중요합니다. 그렇지 않으면 Payload 구성 및 다른 플러그인과 악영향과 충돌을 일으킬 수 있습니다.

새 컬렉션을 추가하는 플러그인을 구축하려고 한다고 가정해봅시다:

```
config.collections = [
  ...(config.collections || []),
 newCollection,
  // 여기에 추가 컬렉션 추가
]
```

먼저 기존 컬렉션을 잃지 않도록 `config.collections`를 전개해야 합니다. 그런 다음 일반 Payload 구성에서와 마찬가지로 추가 컬렉션을 추가할 수 있습니다.

이 동일한 로직이 admin, globals, hooks와 같은 다른 배열 및 객체와 같은 속성에도 적용됩니다:

```
config.globals = [
  ...(config.globals || []),
  // 여기에 추가 글로벌 추가
]

config.hooks = {
  ...(config.hooks || {}),
  // 여기에 추가 훅 추가
}
```

### 함수 확장

함수 속성은 전개 구문을 사용할 수 없습니다. 이를 확장하는 방법은 기존 함수가 존재하는 경우 실행한 다음 추가 기능을 실행하는 것입니다.

다음은 `onInit` 속성을 확장하는 예시입니다:

```
config.onInit = async payload => {
  if (incomingConfig.onInit) await incomingConfig.onInit(payload)

  // onInitExtension 함수를 사용하여 추가 onInit 코드 추가
  onInitExtension(pluginOptions, payload)
}
```

## 타입

플러그인에 옵션이 있는 경우, 메인 `index.ts`에서 내보내지는 별도의 파일에서 이러한 옵션에 대한 타입을 정의하고 제공해야 합니다.

```
export interface PluginTypes {
  /**
   * 플러그인 활성화 또는 비활성화
   * @default false
   */
  enabled?: boolean
}

```

가능하면 옵션과 그 타입을 설명하기 위해 [JSDoc 주석](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#types-1)을 포함하세요. 이를 통해 개발자가 편집기에서 옵션에 대한 세부 정보를 볼 수 있습니다.

## 모범 사례

위에서 다룬 설정 외에도 따라야 할 다른 모범 사례들이 있습니다:

### 활성화/비활성화 옵션 제공

더 나은 사용자 경험을 위해 플러그인을 제거하지 않고도 비활성화할 수 있는 방법을 제공하세요.

### GitHub CI 워크플로우에 테스트 포함

패키지에 대한 테스트를 구성했다면, 플러그인 저장소에 커밋할 때마다 테스트가 실행되도록 워크플로우에 통합하세요. [GitHub CI 워크플로우에서 테스트를 구성하는 방법](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs)에 대해 자세히 알아보세요.

### 완성된 플러그인을 npm에 게시

플러그인이 완료된 후 다른 사람들이 공유하고 사용할 수 있도록 하는 가장 좋은 방법은 npm 패키지를 게시하는 것입니다. 이 프로세스는 간단하고 잘 문서화되어 있습니다. [npm 패키지 생성 및 게시에 대해 여기서](https://docs.npmjs.com/creating-and-publishing-scoped-public-packages/) 자세히 알아보세요.

### payload-plugin 토픽 태그 추가

GitHub 저장소에 **payload-plugin** 태그를 적용하세요. 이렇게 하면 플러그인의 가시성이 높아지고 [기존 Payload 플러그인](https://github.com/topics/payload-plugin)과 함께 나열됩니다.

### 시맨틱 버전 관리(SemVer) 사용

[시맨틱 버전 관리](https://semver.org/) (SemVer) 시스템으로 변경 사항의 성격(major, minor, patch)을 반영하는 버전 번호를 릴리스합니다. 모든 주요 버전이 Payload 호환성을 참조하도록 하세요.