---
description: 필드는 Payload의 구성 요소입니다. 필드를 추가하거나 제거하는 방법, 필드 타입 변경, 훅 추가, 액세스 제어 및 유효성 검사를 정의하는 방법을 알아보세요.
keywords: 개요, 필드, 구성, 설정, 문서, 콘텐츠 관리 시스템, cms, 헤드리스, javascript, node, react, nextjs
label: 개요
order: 10
title: 필드 개요
---

필드는 Payload의 구성 요소입니다. [데이터베이스](../database/overview)에 저장될 문서의 스키마를 정의하고, [관리자 패널](../admin/overview) 내에서 해당하는 UI를 자동으로 생성합니다.

단순한 텍스트 문자열부터 중첩된 배열과 블록까지 다양한 [필드 타입](#field-types) 중에서 선택할 수 있습니다. 대부분의 필드는 데이터베이스에 데이터를 저장하지만, 일부는 순수하게 표현 목적입니다. 필드는 [커스텀 유효성 검사](#validation), [조건부 로직](./overview#conditional-logic), [액세스 제어](#field-level-access-control), [훅](#field-level-hooks) 등을 가질 수 있습니다.

필드는 기본 데이터 구조에 영향을 주지 않고 외관과 동작을 무한히 커스터마이징할 수 있습니다. 필드는 [커스텀 필드 컴포넌트](#custom-components)를 사용하여 대폭적인 수정이나 완전한 교체도 견딜 수 있도록 설계되었습니다.

필드를 구성하려면 [컬렉션](../configuration/collections) 또는 [글로벌](../configuration/globals) 구성에서 `fields` 속성을 사용하세요:

```ts
import type { CollectionConfig } from 'payload'

export const Page: CollectionConfig = {
  // ...
  fields: [
    // highlight-line
    // ...
  ],
}
```

## 필드 타입

Payload는 다양한 내장 필드 타입을 제공하며, 각각 고유한 속성과 동작을 가져 어떤 값을 허용할 수 있는지, API에서 어떻게 표현되는지, [관리자 패널](../admin/overview)에서 어떻게 렌더링될지를 결정합니다.

필드를 구성하려면 [컬렉션](../configuration/collections) 또는 [글로벌](../configuration/globals) 구성에서 `fields` 속성을 사용하세요:

```ts
import type { CollectionConfig } from 'payload'

export const Page: CollectionConfig = {
  slug: 'pages',
  // highlight-start
  fields: [
    {
      name: 'field',
      type: 'text',
    },
  ],
  // highlight-end
}
```

<Banner type="warning">
  **알림:** 각 필드는 최소한 `type` 속성을 가진 객체입니다. 이는 필드를 해당하는 필드 타입과 연결합니다. [자세한 내용](#field-options).
</Banner>

Payload에는 세 가지 주요 필드 카테고리가 있습니다:

- [데이터 필드](#data-fields)
- [표현 필드](#presentational-fields)
- [가상 필드](#virtual-fields)

필드 작성을 시작하려면 먼저 애플리케이션에 가장 적합한 [필드 타입](#field-types)을 결정하세요. 그런 다음 선택한 필드 타입의 [필드 옵션](#field-options)을 사용하여 필드를 작성하세요.

### 데이터 필드

데이터 필드는 [데이터베이스](../database/overview)에 데이터를 저장하는 데 사용됩니다. 모든 데이터 필드에는 `name` 속성이 있습니다. 이는 필드의 값을 저장하는 데 사용될 키입니다.

사용 가능한 데이터 필드는 다음과 같습니다:

- [Array](./array) - 반복 콘텐츠용, 중첩된 필드 지원
- [Blocks](./blocks) - 블록 기반 콘텐츠용, 중첩된 필드 지원
- [Checkbox](./checkbox) - boolean true / false 값 저장
- [Code](./code) - 문자열을 저장하는 코드 편집기 인터페이스 렌더링
- [Date](./date) - 날짜 선택기를 렌더링하고 타임스탬프 저장
- [Email](./email) - 값이 올바른 형식의 이메일 주소인지 확인
- [Group](./group) - 키가 있는 객체 내에 필드 중첩
- [JSON](./json) - JSON 객체를 저장하는 JSON 편집기 인터페이스 렌더링
- [Number](./number) - 숫자 값 저장
- [Point](./point) - 위치 데이터용, 기하학적 좌표 저장
- [Radio](./radio) - 하나의 값만 선택할 수 있는 라디오 버튼 그룹 렌더링
- [Relationship](./relationship) - 다른 컬렉션과의 관계 할당
- [Rich Text](./rich-text) - 완전히 확장 가능한 리치 텍스트 편집기 렌더링
- [Select](./select) - 드롭다운 / 픽리스트 스타일 값 선택기 렌더링
- [Tabs (Named)](./tabs) - 그룹과 유사하지만 탭 레이아웃 내에서 중첩된 필드 렌더링
- [Text](./text) - 문자열을 저장하는 간단한 텍스트 입력
- [Textarea](./textarea) - 텍스트와 유사하지만 여러 줄 입력 허용
- [Upload](./upload) - 로컬 파일 및 이미지 업로드 허용

### 표현 필드

표현 필드는 데이터베이스에 데이터를 저장하지 않습니다. 대신 [관리자 패널](../admin/overview)에서 다른 필드를 구성하고 표현하거나 커스텀 UI 컴포넌트를 추가하는 데 사용됩니다.

사용 가능한 표현 필드는 다음과 같습니다:

- [Collapsible](../fields/collapsible) - 접을 수 있는 컴포넌트 내에 필드 중첩
- [Row](../fields/row) - 필드를 수평으로 정렬
- [Tabs (Unnamed)](../fields/tabs) - 탭 레이아웃 내에 필드 중첩
- [UI](../fields/ui) - 커스텀 UI 컴포넌트를 위한 빈 필드

### 가상 필드

가상 필드는 데이터베이스에 저장되지 않은 데이터를 표시하는 데 사용됩니다. 훅 등을 통해 API 응답 내에서 채워지는 계산된 값을 표시하는 데 유용합니다.

사용 가능한 가상 필드는 다음과 같습니다:

- [Join](../fields/join) - 필드 간의 양방향 데이터 바인딩 달성

<Banner type="success">
  **팁:** 필요한 내장 필드 타입이 없나요? 직접 만드세요! [필드 유효성 검사](#validation)와 [커스텀 컴포넌트](../custom-components/overview)의 조합을 사용하여 [관리자 패널](../admin/overview) 내에서 컴포넌트가 작동하는 방식 전체를 재정의하여 효과적으로 자신만의 필드 타입을 만들 수 있습니다.
</Banner>

## 필드 옵션

모든 필드에는 최소한 `type` 속성이 필요합니다. 이는 필드를 해당하는 [필드 타입](#field-types)과 연결하여 [관리자 패널](../admin/overview) 내에서의 외관과 동작을 결정합니다. 각 필드 타입은 고유한 타입에 기반한 고유한 옵션 집합을 가집니다.

필드의 타입을 설정하려면 필드 구성에서 `type` 속성을 사용하세요:

```ts
import type { Field } from 'payload'

export const MyField: Field = {
  type: 'text', // highlight-line
  name: 'myField',
}
```

<Banner type="warning">
  구성 옵션의 전체 목록은 각 [필드 타입](#field-types) 문서를 참조하세요.
</Banner>

### 필드 이름

모든 [데이터 필드](#data-fields)에는 `name` 속성이 필요합니다. 이는 데이터베이스에서 필드의 값을 저장하고 검색하는 데 사용될 키입니다. 이 속성은 이 필드의 형제들 사이에서 고유해야 합니다.

필드의 이름을 설정하려면 필드 구성에서 `name` 속성을 사용하세요:

```ts
import type { Field } from 'payload'

export const MyField: Field = {
  type: 'text',
  name: 'myField', // highlight-line
}
```

Payload는 내부 사용을 위해 다양한 필드 이름을 예약합니다. 예약된 필드 이름을 사용하면 구성에서 필드가 제거됩니다.

다음 필드 이름은 금지되며 사용할 수 없습니다:

- `__v`
- `salt`
- `hash`
- `file`
- `status` - Postgres 어댑터 사용 시 및 드래프트가 활성화된 경우

### 필드 수준 훅

문서 수준에서 [훅](../hooks/overview)을 정의할 수 있는 것 외에도, 필드별로 극도로 세분화된 로직을 정의할 수 있습니다.

필드 수준 훅을 정의하려면 필드 구성에서 `hooks` 속성을 사용하세요:

```ts
import type { Field } from 'payload'

export const MyField: Field = {
  type: 'text',
  name: 'myField',
  // highlight-start
  hooks: {
    // ...
  },
  // highlight-end
}
```

필드 수준 훅에 대한 자세한 내용은 [필드 훅](../hooks/fields) 문서를 참조하세요.

### 필드 수준 액세스 제어

문서 수준에서 [액세스 제어](../access-control/overview)를 정의할 수 있는 것 외에도, 필드별로 극도로 세분화된 권한을 정의할 수 있습니다.

필드 수준 액세스 제어를 정의하려면 필드 구성에서 `access` 속성을 사용하세요:

```ts
import type { Field } from 'payload'

export const MyField: Field = {
  type: 'text',
  name: 'myField',
  // highlight-start
  access: {
    // ...
  },
  // highlight-end
}
```

필드 수준 액세스 제어에 대한 자세한 내용은 [필드 액세스 제어](../access-control/fields) 문서를 참조하세요.

### 기본값

필드는 초기값으로 선택적으로 미리 채워질 수 있습니다. 이는 `create` 또는 `update` 작업 중에 누락되거나 정의되지 않은 필드 값을 채우기 위해 [관리자 패널](../admin/overview)과 API 요청 모두에서 사용됩니다.

필드의 기본값을 설정하려면 필드 구성에서 `defaultValue` 속성을 사용하세요:

```ts
import type { Field } from 'payload'

export const MyField: Field = {
  type: 'text',
  name: 'myField',
  defaultValue: 'Hello, World!', // highlight-line
}
```

기본값은 정적 값 또는 값을 반환하는 함수로 정의할 수 있습니다. `defaultValue`가 정적으로 정의되면 Payload의 [데이터베이스 어댑터](../database/overview)가 데이터베이스 스키마나 모델에 적용합니다.

함수는 다음 인수 속성을 사용하여 작성할 수 있습니다:

- `user` - 인증된 사용자 객체
- `locale` - 현재 선택된 로케일 문자열
- `req` - `PayloadRequest` 객체

다음은 `defaultValue` 함수의 예시입니다:

```ts
import type { Field } from 'payload'

const translation: {
  en: 'Written by'
  es: 'Escrito por'
}

export const myField: Field = {
  name: 'attribution',
  type: 'text',
  // highlight-start
  defaultValue: ({ user, locale, req }) =>
    `${translation[locale]} ${user.name}`,
  // highlight-end
}
```

<Banner type="success">
  **팁:** 비동기 `defaultValue` 함수를 사용하여 API 요청이나 `req.payload`를 사용한 로컬 API에서 데이터로 필드를 채울 수 있습니다.
</Banner>

### 유효성 검사

필드는 [필드 타입](#field-types)과 `required`나 `min`, `max` 값 제약 조건과 같은 다른 [필드 옵션](#field-options)에 기반하여 자동으로 유효성을 검사합니다. 그러나 필요한 경우 자신만의 커스텀 유효성 검사 함수를 제공하여 필드 유효성 검사를 커스터마이징하거나 완전히 교체할 수 있습니다.

커스텀 필드 유효성 검사 함수를 설정하려면 필드 구성에서 `validate` 속성을 사용하세요:

```ts
import type { Field } from 'payload'

export const MyField: Field = {
  type: 'text',
  name: 'myField',
  validate: (value) => Boolean(value) || 'This field is required', // highlight-line
}
```

커스텀 유효성 검사 함수는 `true` 또는 API 응답에 표시할 오류 메시지를 나타내는 `string`을 반환해야 합니다.

다음 인수가 `validate` 함수에 제공됩니다:

| 인수    | 설명                                                          |
| ------- | ------------------------------------------------------------- |
| `value` | 유효성을 검사하는 필드의 값.                                  |
| `ctx`   | 추가 데이터와 컨텍스트가 있는 객체. [자세한 내용](#validation-context) |

#### 유효성 검사 컨텍스트

`ctx` 인수에는 전체 문서 데이터, 형제 필드 데이터, 현재 작업, 현재 인증된 사용자와 같은 기타 유용한 정보가 포함됩니다:

```ts
import type { Field } from 'payload'

export const MyField: Field = {
  type: 'text',
  name: 'myField',
  // highlight-start
  validate: (val, { user }) =>
    Boolean(user) || 'You must be logged in to save this field',
  // highlight-end
}
```

다음 추가 속성이 `ctx` 객체에서 제공됩니다:

| 속성          | 설명                                                                                                                                    |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| `data`        | 현재 편집 중인 전체 컬렉션 또는 글로벌 문서를 포함하는 객체.                                                                            |
| `siblingData` | 이 필드와 동일한 부모 내의 필드로 범위가 지정된 문서 데이터를 포함하는 객체.                                                            |
| `operation`   | UI 작업 또는 API 호출에 따라 `create` 또는 `update`가 됩니다.                                                                           |
| `path`        | 배열 인덱스를 포함한 문자열 세그먼트의 배열로 표현되는 스키마의 필드 전체 경로. 예: `['group', 'myArray', '1', 'textField']`.            |
| `id`          | 현재 편집 중인 문서의 `id`. `create` 작업 중에는 `id`가 `undefined`입니다.                                                              |
| `req`         | 현재 HTTP 요청 객체. `payload`, `user` 등을 포함합니다.                                                                                |
| `event`       | 현재 작업에 따라 `onChange` 또는 `submit` 중 하나. 성능 옵트인으로 사용됩니다. [자세한 내용](#validation-performance).                 |

#### 현지화 및 내장 오류 메시지

`req` 객체에서 제공되는 번역 함수를 활용하여 현지화된 오류 메시지를 반환할 수 있습니다:

```ts
import type { Field } from 'payload'

export const MyField: Field = {
  type: 'text',
  name: 'myField',
  validate: (value, { req: { t } }) =>
    Boolean(value) || t('validation:required'), // highlight-line
}
```

이렇게 하면 [커스텀 번역](https://payloadcms.com/docs/configuration/i18n#custom-translations)뿐만 아니라 Payload의 내장 오류 메시지(위 예시에서 사용된 `validation:required`와 같은)도 사용할 수 있습니다. 사용 가능한 번역 문자열의 전체 목록은 Payload의 [영어 번역 파일](https://github.com/payloadcms/payload/blob/main/packages/translations/src/languages/en.ts)을 참조하세요.

#### 기본 필드 유효성 검사 재사용

커스텀 유효성 검사 함수를 사용할 때 Payload는 기본값 대신 여러분의 것을 사용합니다. 그러나 기본 유효성 검사를 자신만의 커스텀 로직으로 단순히 보강하고 싶을 수도 있습니다.

기본 필드 유효성 검사를 재사용하려면 커스텀 유효성 검사 함수 내에서 호출하세요:

```ts
import { text } from 'payload/shared'

const field: Field = {
  name: 'notBad',
  type: 'text',
  validate: (val, args) => {
    if (val === 'bad') return 'This cannot be "bad"'
    return text(val, args) // highlight-line
  },
}
```

다음은 모든 기본 필드 유효성 검사 함수의 목록입니다:

```ts
import {
  array,
  blocks,
  checkbox,
  code,
  date,
  email,
  json,
  number,
  point,
  radio,
  relationship,
  richText,
  select,
  tabs,
  text,
  textarea,
  upload,
} from 'payload/shared'
```

#### 유효성 검사 성능

비동기 또는 계산적으로 무거운 유효성 검사 함수를 작성할 때는 성능에 미치는 영향을 고려하는 것이 중요합니다. 관리자 패널 내에서 유효성 검사는 필드의 모든 변경에서 실행되므로 가능한 한 가볍고 필요할 때만 실행되어야 합니다.

데이터베이스 쿼리와 같은 비용이 많이 드는 유효성 검사를 수행해야 하는 경우, `ctx` 객체의 `event` 속성을 사용하여 폼 제출 시에만 해당 특정 유효성 검사를 실행하는 것을 고려하세요.

비동기 유효성 검사 함수를 작성하려면 `async` 키워드를 사용하여 함수를 정의하세요:

```ts
import type { CollectionConfig } from 'payload'

export const Orders: CollectionConfig = {
  slug: 'orders',
  fields: [
    {
      name: 'customerNumber',
      type: 'text',
      // highlight-start
      validate: async (val, { event }) => {
        if (event === 'onChange') {
          return true
        }

        // 폼이 제출될 때만 비용이 많이 드는 유효성 검사 수행
        const response = await fetch(`https://your-api.com/customers/${val}`)

        if (response.ok) {
          return true
        }

        return 'The customer number provided does not match any customers within our records.'
      },
      // highlight-end
    },
  ],
}
```

<Banner type="success">
  더 많은 성능 팁은 [성능 문서](../performance/overview)를 참조하세요.
</Banner>

## 커스텀 ID 필드

모든 [컬렉션](../configuration/collections)은 자동으로 자신만의 ID 필드를 생성합니다. 필요한 경우 구성에 명시적인 ID 필드를 제공하여 이 동작을 재정의할 수 있습니다. 이 필드는 필수이거나 동적으로 ID를 생성하는 훅을 가져야 합니다.

커스텀 ID 필드를 정의하려면 `name` 속성이 `id`로 설정된 최상위 필드를 추가하세요:

```ts
import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  // ...
  fields: [
    {
      name: 'id', // highlight-line
      required: true,
      type: 'number',
    },
  ],
}
```

<Banner type="warning">
  **알림:** 커스텀 ID 필드는 [`Number`](./number) 또는 [`Text`](./text) 타입만 가능합니다. `text` 타입의 커스텀 ID 필드는 `/` 또는 `.` 문자를 포함해서는 안 됩니다.
</Banner>

## 관리자 옵션

모든 필드 구성의 `admin` 속성을 통해 [관리자 패널](../admin/overview) 내에서 필드의 모양과 동작을 커스터마이징할 수 있습니다:

```ts
import type { CollectionConfig } from 'payload'

export const CollectionConfig: CollectionConfig = {
  // ...
  fields: [
    // ...
    {
      name: 'myField',
      type: 'text',
      admin: {
        // highlight-line
        // ...
      },
    },
  ],
}
```

다음 옵션들이 사용 가능합니다:

| 옵션                    | 설명                                                                                                                                               |
| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`condition`**         | 다른 필드를 기반으로 프로그래밍 방식으로 필드를 표시/숨기기. [자세한 내용](#conditional-logic).                                                     |
| **`components`**        | 모든 필드 컴포넌트를 정의하는 [커스텀 컴포넌트](../custom-components/overview)로 교체할 수 있습니다.                                                |
| **`description`**       | 편집자에게 더 많은 정보를 제공하기 위해 필드와 함께 표시할 도움말 텍스트. [자세한 내용](#description).                                              |
| **`position`**          | `position: 'sidebar'`를 정의하여 필드가 사이드바에 렌더링되도록 지정.                                                                              |
| **`width`**             | 필드의 너비를 제한. 픽셀, 백분율 등 모든 문자열 기반 값을 전달할 수 있습니다. 이 속성은 필드가 수평으로 구성될 수 있는 `Row` 타입 내에 중첩될 때 특히 유용합니다. |
| **`style`**             | 필드의 루트 요소에 주입할 [CSS 속성](https://developer.mozilla.org/en-US/docs/Web/CSS).                                                           |
| **`className`**         | 필드의 루트 DOM 요소에 [CSS 클래스 속성](https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors)을 연결.                               |
| **`readOnly`**          | 필드를 `readOnly`로 설정하면 API에는 전혀 영향을 주지 않지만 관리자 컴포넌트의 편집 가능성을 비활성화하여 편집자가 필드 값을 수정하지 못하도록 합니다.   |
| **`disabled`**          | 필드가 `disabled`되면 [관리자 패널](../admin/overview)에서 완전히 생략됩니다.                                                                        |
| **`disableBulkEdit`**   | `disableBulkEdit`을 `true`로 설정하면 여러 문서를 편집할 때 선택 옵션에서 필드가 나타나지 않습니다. UI 필드의 기본값은 `true`입니다.                   |
| **`disableListColumn`** | `disableListColumn`을 `true`로 설정하면 목록 보기 열 선택기에서 필드가 나타나지 않습니다.                                                           |
| **`disableListFilter`** | `disableListFilter`를 `true`로 설정하면 목록 보기 필터 옵션에서 필드가 나타나지 않습니다.                                                          |
| **`hidden`**            | 필드를 `hidden` 입력 타입으로 변환합니다. 관리자 패널의 요청과 함께 여전히 값을 제출하지만 필드 자체는 편집자에게 표시되지 않습니다.                  |

### 필드 설명

필드 설명은 특별한 지침과 같은 필드에 대한 추가 정보를 편집자에게 제공하는 데 사용됩니다. 배치는 필드마다 다르지만 일반적으로 필드 입력 아래에 미묘한 스타일 차이로 표시됩니다.

설명은 세 가지 방법으로 구성할 수 있습니다:

- 문자열로.
- 문자열을 반환하는 함수로. [자세한 내용](#description-functions).
- React 컴포넌트로. [자세한 내용](#description).

필드에 커스텀 설명을 추가하려면 필드 구성에서 `admin.description` 속성을 사용하세요:

```ts
import type { CollectionConfig } from 'payload'

export const MyCollectionConfig: CollectionConfig = {
  // ...
  fields: [
    // ...
    {
      name: 'myField',
      type: 'text',
      admin: {
        description: 'Hello, world!', // highlight-line
      },
    },
  ],
}
```

<Banner type="warning">
  **알림:** 필드 설명을 [커스텀 컴포넌트](../custom-components/overview)로 교체하려면 `admin.components.Description` 속성을 사용하세요. [자세한 내용](#description).
</Banner>

#### 설명 함수

커스텀 설명은 함수로도 정의할 수 있습니다. 설명 함수는 서버에서 실행되며 사용자의 현재 [로케일](../configuration/localization)을 기반으로 간단한 설명을 형식화하는 데 사용할 수 있습니다.

필드에 설명 함수를 추가하려면 필드 구성에서 `admin.description` 속성을 _함수_로 설정하세요:

```ts
import type { CollectionConfig } from 'payload'

export const MyCollectionConfig: CollectionConfig = {
  // ...
  fields: [
    // ...
    {
      name: 'myField',
      type: 'text',
      admin: {
        description: ({ t }) => `${t('Hello, world!')}`, // highlight-line
      },
    },
  ],
}
```

모든 설명 함수는 다음 인수를 받습니다:

| 인수    | 설명                                                                           |
| ------- | ------------------------------------------------------------------------------ |
| **`t`** | 관리자 패널을 국제화하는 데 사용되는 `t` 함수. [자세한 내용](../configuration/i18n) |

<Banner type="info">
  **참고:** 폼 내에서 실시간 업데이트를 구독해야 하는 경우 설명 컴포넌트를 대신 사용하세요. [자세한 내용](#description).
</Banner>

### 조건부 로직

필드별로 조건부 로직을 활용하여 다른 필드가 무엇을 하고 있는지에 기반하여 필드를 표시하고 숨길 수 있습니다. 필드의 관리자 구성의 `condition` 속성은 다음 인수를 받는 함수를 허용합니다:

| 인수              | 설명                                                   |
| ----------------- | ------------------------------------------------------ |
| **`data`**        | 현재 편집 중인 전체 문서의 데이터.                     |
| **`siblingData`** | 조건이 있는 필드의 직접 형제인 필드만.                 |
| **`ctx`**         | 필드의 위치와 사용자에 대한 추가 정보를 포함하는 객체. |

`ctx` 객체:

| 속성            | 설명                                                                                                                                    |
| --------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| **`blockData`** | 가장 가까운 부모 블록의 데이터. 필드가 블록 내부에 있지 않으면 `undefined`입니다.                                                       |
| **`operation`** | 필드 타입이 현재 실행 중인 작업과 관련된 문자열.                                                                                        |
| **`path`**      | 배열 인덱스를 포함한 문자열 세그먼트의 배열로 표현되는 스키마의 필드 전체 경로. 예: `['group', 'myArray', '1', 'textField']`.            |
| **`user`**      | 현재 인증된 사용자 객체.                                                                                                                |

`condition` 함수는 필드가 표시되어야 하는지 여부를 제어하는 boolean을 반환해야 합니다.

**예시:**

```ts
{
  fields: [
    {
      name: 'enableGreeting',
      type: 'checkbox',
      defaultValue: false,
    },
    {
      name: 'greeting',
      type: 'text',
      admin: {
        // highlight-start
        condition: (data, siblingData, { blockData, path, user }) => {
          if (data.enableGreeting) {
            return true
          } else {
            return false
          }
        },
        // highlight-end
      },
    },
  ]
}
```

### 커스텀 컴포넌트

[관리자 패널](../admin/overview) 내에서 필드는 세 곳에서 표현됩니다:

- [Field](#field) - 편집 보기에서 렌더링되는 실제 폼 필드.
- [Cell](#cell) - 목록 보기에서 렌더링되는 테이블 셀 컴포넌트.
- [Filter](#filter) - 목록 보기에서 렌더링되는 필터 컴포넌트.
- [Diff](#diff) - 버전 차이 보기에서 렌더링되는 차이 컴포넌트

필드 구성에서 `admin.components` 속성을 사용하여 필드 컴포넌트를 자신만의 것으로 교체하세요:

```ts
import type { CollectionConfig } from 'payload'

export const CollectionConfig: CollectionConfig = {
  // ...
  fields: [
    // ...
    {
      // ...
      admin: {
        components: {
          // highlight-line
          // ...
        },
      },
    },
  ],
}
```

다음 옵션들이 사용 가능합니다:

| 컴포넌트          | 설명                                                                                                |
| ----------------- | --------------------------------------------------------------------------------------------------- |
| **`Field`**       | 편집 보기에서 렌더링되는 폼 필드. [자세한 내용](#field).                                            |
| **`Cell`**        | 목록 보기에서 렌더링되는 테이블 셀. [자세한 내용](#cell).                                           |
| **`Filter`**      | 목록 보기에서 렌더링되는 필터 컴포넌트. [자세한 내용](#filter).                                     |
| **`Label`**       | 필드 컴포넌트의 기본 라벨을 재정의. [자세한 내용](#label).                                          |
| **`Error`**       | 필드 컴포넌트의 기본 오류를 재정의. [자세한 내용](#error).                                          |
| **`Diff`**        | 버전 차이 보기에서 렌더링되는 기본 차이 컴포넌트를 재정의. [자세한 내용](#diff).                    |
| **`Description`** | 필드 컴포넌트의 기본 설명을 재정의. [자세한 내용](#description).                                    |
| **`beforeInput`** | 필드 컴포넌트의 입력 앞에 추가될 요소들의 배열. [자세한 내용](#afterinput-and-beforeinput).         |
| **`afterInput`**  | 필드 컴포넌트의 입력 뒤에 추가될 요소들의 배열. [자세한 내용](#afterinput-and-beforeinput).         |

#### Field

필드 컴포넌트는 편집 보기에서 렌더링되는 실제 폼 필드입니다. 이는 문서를 편집할 때 사용자가 상호작용할 입력입니다.

자신만의 필드 컴포넌트로 교체하려면 필드 구성에서 `admin.components.Field` 속성을 사용하세요:

```ts
import type { CollectionConfig } from 'payload'

export const CollectionConfig: CollectionConfig = {
  // ...
  fields: [
    // ...
    {
      // ...
      admin: {
        components: {
          Field: '/path/to/MyFieldComponent', // highlight-line
        },
      },
    },
  ],
}
```

_커스텀 컴포넌트 구축 방법에 대한 자세한 내용은 [커스텀 컴포넌트 구축](../custom-components/overview#building-custom-components)를 참조하세요._

<Banner type="warning">
  전체 필드 컴포넌트를 교체하는 대신 [`Label`](#label), [`Error`](#error), [`beforeInput`](#afterinput-and-beforinput), [`afterInput`](#afterinput-and-beforinput) 속성을 사용하여 특정 부분만 교체하거나 삽입할 수 있습니다.
</Banner>

##### 기본 Props

모든 필드 컴포넌트는 기본적으로 다음 props를 받습니다:

| 속성                 | 설명                                                                                                                                                                                          |
| -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`docPreferences`** | 문서의 [Preferences](../admin/preferences)를 포함하는 객체.                                                                                                                                   |
| **`field`**          | 클라이언트 컴포넌트에서는 정제된 클라이언트 필드 구성입니다. 서버 컴포넌트에서는 원본 필드 구성입니다. 서버 컴포넌트는 `clientField` prop을 통해 정제된 필드 구성도 받습니다(아래 참조). |
| **`locale`**         | 필드의 로케일. [자세한 내용](../configuration/localization).                                                                                                                                  |
| **`readOnly`**       | 필드가 읽기 전용인지 여부를 나타내는 boolean 값.                                                                                                                                              |
| **`user`**           | 현재 인증된 사용자. [자세한 내용](../authentication/overview).                                                                                                                                |
| **`validate`**       | 필드를 유효성 검사하는 데 사용할 수 있는 함수.                                                                                                                                                |
| **`path`**           | 런타임에서 필드로의 직접, 동적 경로를 나타내는 문자열. 예: `myGroup.myArray.0.myField`.                                                                                                      |
| **`schemaPath`**     | 필드 구성으로의 직접, 정적 경로를 나타내는 문자열. 예: `posts.myGroup.myArray.myField`.                                                                                                      |
| **`indexPath`**      | _가장 가까운 명명된 조상 필드 내에서_ 필드로의 경로를 나타내는 하이픈으로 구분된 문자열. 예: `0-0`                                                                                            |

위의 props 외에도 모든 서버 컴포넌트는 다음 props도 받습니다:

| 속성              | 설명                                                             |
| ----------------- | ---------------------------------------------------------------- |
| **`clientField`** | 직렬화 가능한 클라이언트 필드 구성.                              |
| **`field`**       | 필드 구성.                                                       |
| **`data`**        | 현재 편집 중인 문서.                                             |
| **`i18n`**        | [i18n](../configuration/i18n) 객체.                             |
| **`payload`**     | [Payload](../local-api/overview) 클래스.                        |
| **`permissions`** | 현재 인증된 사용자를 기반으로 한 필드 권한.                      |
| **`siblingData`** | 필드의 형제 데이터.                                              |
| **`user`**        | 현재 인증된 사용자. [자세한 내용](../authentication/overview).   |
| **`value`**       | 렌더링 시점에서의 필드 값.                                       |

##### 폼에서 값 송수신

`Field` 컴포넌트를 교체할 때 폼 자체에서 필드의 `value`를 송수신하는 책임이 있습니다.

이를 위해 `@payloadcms/ui`에서 [`useField`](../admin/react-hooks#usefield) 훅을 가져와 필드의 값을 관리하세요:

```tsx
'use client'
import { useField } from '@payloadcms/ui'

export const CustomTextField: React.FC = () => {
  const { value, setValue } = useField() // highlight-line

  return <input onChange={(e) => setValue(e.target.value)} value={value} />
}
```

<Banner type="success">
  사용 가능한 모든 React 훅의 전체 목록은 [Payload React Hooks](../admin/react-hooks) 문서를 참조하세요. 추가 도움은 [커스텀 컴포넌트 구축](../custom-components/overview#building-custom-components)을 참조하세요.
</Banner>

##### TypeScript#field-component-types

커스텀 필드 컴포넌트를 구축할 때 클라이언트 필드 props를 가져와 컴포넌트의 타입 안전성을 보장할 수 있습니다. 필드 컴포넌트에 대한 명시적 타입, 모든 필드 타입과 서버/클라이언트 환경에 대한 타입이 있습니다. 관례는 필드 타입을 대상 타입 앞에 붙이는 것입니다. 예: `TextFieldClientComponent`:

```tsx
import type {
  TextFieldClientComponent,
  TextFieldServerComponent,
  TextFieldClientProps,
  TextFieldServerProps,
  // ...각 필드 타입에 대해 계속
} from 'payload'
```

정확한 타입 가져오기는 각 개별 필드 타입을 참조하세요.

#### Cell

셀 컴포넌트는 목록 보기의 테이블에서 렌더링됩니다. 테이블 셀에 표시될 때 필드의 값을 나타냅니다.

자신만의 셀 컴포넌트로 교체하려면 필드 구성에서 `admin.components.Cell` 속성을 사용하세요:

```ts
import type { Field } from 'payload'

export const myField: Field = {
  name: 'myField',
  type: 'text',
  admin: {
    components: {
      Cell: '/path/to/MyCustomCellComponent', // highlight-line
    },
  },
}
```

모든 셀 컴포넌트는 동일한 [기본 필드 컴포넌트 Props](#field)와 다음을 받습니다:

| 속성          | 설명                                                    |
| ------------- | ------------------------------------------------------- |
| **`link`**    | 이 셀이 링크로 감싸져야 하는지를 나타내는 boolean.      |
| **`onClick`** | 셀이 클릭될 때 호출되는 함수.                           |

커스텀 컴포넌트 자체를 구축하는 방법에 대한 자세한 내용은 [커스텀 컴포넌트 구축](../custom-components/overview#building-custom-components)을 참조하세요.

#### Filter

필터 컴포넌트는 필터를 구축할 때 이 필드를 나타내는 데 사용되는 목록 보기의 "Filter By" 드롭다운 내에서 렌더링되는 실제 입력 요소입니다.

자신만의 필터 컴포넌트로 교체하려면 필드 구성에서 `admin.components.Filter` 속성을 사용하세요:

```ts
import type { Field } from 'payload'

export const myField: Field = {
  name: 'myField',
  type: 'text',
  admin: {
    components: {
      Filter: '/path/to/MyCustomFilterComponent', // highlight-line
    },
  },
}
```

모든 커스텀 필터 컴포넌트는 동일한 [기본 필드 컴포넌트 Props](#field)를 받습니다.

커스텀 컴포넌트 자체를 구축하는 방법에 대한 자세한 내용은 [커스텀 컴포넌트 구축](../custom-components/overview#building-custom-components)을 참조하세요.

#### Label

라벨 컴포넌트는 필드가 라벨로 표현되어야 하는 모든 곳에서 렌더링됩니다. 이는 일반적으로 편집 보기에서 사용되지만 목록 보기 및 다른 곳에서도 사용될 수 있습니다.

자신만의 라벨 컴포넌트로 교체하려면 필드 구성에서 `admin.components.Label` 속성을 사용하세요:

```ts
import type { Field } from 'payload'

export const myField: Field = {
  name: 'myField',
  type: 'text',
  admin: {
    components: {
      Label: '/path/to/MyCustomLabelComponent', // highlight-line
    },
  },
}
```

모든 커스텀 라벨 컴포넌트는 동일한 [기본 필드 컴포넌트 Props](#field)를 받습니다.

커스텀 컴포넌트 자체를 구축하는 방법에 대한 자세한 내용은 [커스텀 컴포넌트 구축](../custom-components/overview#building-custom-components)을 참조하세요.

##### TypeScript#label-component-types

커스텀 라벨 컴포넌트를 구축할 때 컴포넌트의 타입 안전성을 보장하기 위해 컴포넌트 타입을 가져올 수 있습니다. 라벨 컴포넌트에 대한 명시적 타입, 모든 필드 타입과 서버/클라이언트 환경에 대한 타입이 있습니다. 관례는 필드 타입에 `LabelServerComponent` 또는 `LabelClientComponent`를 붙이는 것입니다. 예: `TextFieldLabelClientComponent`.

```tsx
import type {
  TextFieldLabelServerComponent,
  TextFieldLabelClientComponent,
  // ...각 필드 타입에 대해 계속
} from 'payload'
```

#### Description

[설명 속성](#field-descriptions) 대신 [커스텀 컴포넌트](../custom-components/overview)를 필드 설명으로 사용할 수도 있습니다. 이는 동적 필드 값을 렌더링하거나 다른 대화형 요소와 같이 사용자에게 더 복잡한 피드백을 제공해야 할 때 유용할 수 있습니다.

필드에 설명 컴포넌트를 추가하려면 필드 구성에서 `admin.components.Description` 속성을 사용하세요:

```ts
import type { CollectionConfig } from 'payload'

export const MyCollectionConfig: CollectionConfig = {
  // ...
  fields: [
    // ...
    {
      name: 'myField',
      type: 'text',
      admin: {
        components: {
          Description: '/path/to/MyCustomDescriptionComponent', // highlight-line
        },
      },
    },
  ],
}
```

모든 커스텀 설명 컴포넌트는 동일한 [기본 필드 컴포넌트 Props](#field)를 받습니다.

커스텀 컴포넌트 자체를 구축하는 방법에 대한 자세한 내용은 [커스텀 컴포넌트 구축](../custom-components/overview#building-custom-components)을 참조하세요.

##### TypeScript#description-component-types

커스텀 설명 컴포넌트를 구축할 때 컴포넌트의 타입 안전성을 보장하기 위해 컴포넌트 props를 가져올 수 있습니다. 설명 컴포넌트에 대한 명시적 타입, 모든 필드 타입과 서버/클라이언트 환경에 대한 타입이 있습니다. 관례는 필드 타입에 `DescriptionServerComponent` 또는 `DescriptionClientComponent`를 붙이는 것입니다. 예: `TextFieldDescriptionClientComponent`.

```tsx
import type {
  TextFieldDescriptionServerComponent,
  TextFieldDescriptionClientComponent,
  // 각 필드 타입에 대해 계속
} from 'payload'
```

#### Error

오류 컴포넌트는 필드가 유효성 검사에 실패할 때 렌더링됩니다. 일반적으로 시각적으로 매력적인 스타일로 필드 입력 아래에 표시됩니다.

자신만의 오류 컴포넌트로 교체하려면 필드 구성에서 `admin.components.Error` 속성을 사용하세요:

```ts
import type { Field } from 'payload'

export const myField: Field = {
  name: 'myField',
  type: 'text',
  admin: {
    components: {
      Error: '/path/to/MyCustomErrorComponent', // highlight-line
    },
  },
}
```

모든 오류 컴포넌트는 [기본 필드 컴포넌트 Props](#field)를 받습니다.

커스텀 컴포넌트 자체를 구축하는 방법에 대한 자세한 내용은 [커스텀 컴포넌트 구축](../custom-components/overview#building-custom-components)을 참조하세요.

##### TypeScript#error-component-types

커스텀 오류 컴포넌트를 구축할 때 컴포넌트의 타입 안전성을 보장하기 위해 컴포넌트 타입을 가져올 수 있습니다. 오류 컴포넌트에 대한 명시적 타입, 모든 필드 타입과 서버/클라이언트 환경에 대한 타입이 있습니다. 관례는 필드 타입에 `ErrorServerComponent` 또는 `ErrorClientComponent`를 붙이는 것입니다. 예: `TextFieldErrorClientComponent`.

```tsx
import type {
  TextFieldErrorServerComponent,
  TextFieldErrorClientComponent,
  // 각 필드 타입에 대해 계속
} from 'payload'
```

#### Diff

차이 컴포넌트는 버전 차이 보기에서 렌더링됩니다. 이는 버전 관리가 활성화된 엔티티에서만 표시됩니다.

자신만의 차이 컴포넌트로 교체하려면 필드 구성에서 `admin.components.Diff` 속성을 사용하세요:

```ts
import type { Field } from 'payload'

export const myField: Field = {
  name: 'myField',
  type: 'text',
  admin: {
    components: {
      Diff: '/path/to/MyCustomDiffComponent', // highlight-line
    },
  },
}
```

모든 오류 컴포넌트는 [기본 필드 컴포넌트 Props](#field)를 받습니다.

커스텀 컴포넌트 자체를 구축하는 방법에 대한 자세한 내용은 [커스텀 컴포넌트 구축](../custom-components/overview#building-custom-components)을 참조하세요.

##### TypeScript#diff-component-types

커스텀 차이 컴포넌트를 구축할 때 컴포넌트의 타입 안전성을 보장하기 위해 컴포넌트 타입을 가져올 수 있습니다. 차이 컴포넌트에 대한 명시적 타입, 모든 필드 타입과 서버/클라이언트 환경에 대한 타입이 있습니다. 관례는 필드 타입에 `DiffServerComponent` 또는 `DiffClientComponent`를 붙이는 것입니다. 예: `TextFieldDiffClientComponent`.

```tsx
import type {
  TextFieldDiffServerComponent,
  TextFieldDiffClientComponent,
  // 각 필드 타입에 대해 계속
} from 'payload'
```

#### afterInput and beforeInput

이러한 속성을 사용하면 이름에서 알 수 있듯이 입력 요소 _앞_과 _뒤_에 여러 컴포넌트를 추가할 수 있습니다. 이는 전체 필드 컴포넌트를 교체하지 않고 필드와 함께 추가 요소를 렌더링해야 할 때 유용합니다.

입력 요소 앞뒤에 컴포넌트를 추가하려면 필드 구성에서 `admin.components.beforeInput`과 `admin.components.afterInput` 속성을 사용하세요:

```ts
import type { CollectionConfig } from 'payload'

export const MyCollectionConfig: CollectionConfig = {
  // ...
  fields: [
    // ...
    {
      name: 'myField',
      type: 'text',
      admin: {
        components: {
          // highlight-start
          beforeInput: ['/path/to/MyCustomComponent'],
          afterInput: ['/path/to/MyOtherCustomComponent'],
          // highlight-end
        },
      },
    },
  ],
}
```

모든 `afterInput`과 `beforeInput` 컴포넌트는 동일한 [기본 필드 컴포넌트 Props](#field)를 받습니다.

커스텀 컴포넌트를 구축하는 방법에 대한 자세한 내용은 [커스텀 컴포넌트 구축](../custom-components/overview#building-custom-components)을 참조하세요.

## TypeScript

`payload` 패키지에서 Payload `Field` 타입과 다른 일반적인 타입들을 가져올 수 있습니다. [자세한 내용](../typescript/overview).

```ts
import type { Field } from 'payload'
```