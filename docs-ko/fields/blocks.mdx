---
title: 블록 필드
label: 블록
order: 30
desc: 블록 필드는 훌륭한 레이아웃 빌더이며 유연한 콘텐츠 모델을 구성하는 데 사용할 수 있습니다. 블록 필드 사용법, 예제 및 옵션을 알아보세요.
keywords: 블록, 필드, 구성, 설정, 문서, 콘텐츠 관리 시스템, cms, 헤드리스, javascript, node, react, nextjs
---

블록 필드는 **매우 강력**하며, 정의한 필드를 기반으로 객체 배열을 저장하고, 배열의 각 항목은 고유한 스키마를 가진 "블록"입니다.

블록은 다양한 콘텐츠 유형을 구축하는 데 사용할 수 있는 유연한 콘텐츠 모델을 만드는 훌륭한 방법입니다:

- 편집자가 고도로 커스터마이징 가능한 페이지나 게시글 레이아웃을 디자인할 수 있도록 하는 레이아웃 빌더 도구. 블록에는 `Quote`, `CallToAction`, `Slider`, `Content`, `Gallery` 등과 같은 구성이 포함될 수 있습니다.
- 사용 가능한 블록 구성이 `Text`, `Select` 또는 `Checkbox`일 수 있는 폼 빌더 도구.
- 타임슬롯이 `Break`, `Presentation` 또는 `BreakoutSession`일 수 있는 가상 이벤트 의제 "타임슬롯".

<LightDarkImage
  srcLight="https://payloadcms.com/images/docs/fields/blocks.png"
  srcDark="https://payloadcms.com/images/docs/fields/blocks-dark.png"
  alt="블록 추가 드로어 보기의 관리자 패널 스크린샷"
  caption="블록 추가 드로어 보기의 관리자 패널 스크린샷"
/>

블록 필드를 추가하려면 [필드 Config](./overview)에서 `type`을 `blocks`로 설정하세요:

```ts
import type { Field } from 'payload'

export const MyBlocksField: Field = {
  // ...
  // highlight-start
  type: 'blocks',
  blocks: [
    // ...
  ],
  // highlight-end
}
```

## 구성 옵션

| 옵션                   | 설명                                                                                                                                                                                      |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`name`** \*          | 데이터베이스에 저장되고 검색될 때 속성 이름으로 사용됩니다. [자세한 내용](/docs/fields/overview#field-names).                                                                            |
| **`label`**            | 관리자 패널에서 제목으로 사용되는 텍스트 또는 각 언어의 키가 있는 객체. 정의되지 않은 경우 name에서 자동 생성됩니다.                                                                      |
| **`blocks`** \*        | 이 필드에서 사용할 수 있도록 할 [블록 구성](/docs/fields/blocks#block-configs) 배열.                                                                                                      |
| **`validate`**         | 관리자 패널과 백엔드 모두에서 실행될 커스텀 유효성 검사 함수를 제공합니다. [자세한 내용](/docs/fields/overview#validation).                                                              |
| **`minRows`**          | 값이 존재할 때 유효성 검사 중 허용되는 최소 항목 수.                                                                                                                                      |
| **`maxRows`**          | 값이 존재할 때 유효성 검사 중 허용되는 최대 항목 수.                                                                                                                                      |
| **`saveToJWT`**        | 이 필드가 최상위 수준이고 [인증](/docs/authentication/overview)을 지원하는 구성에 중첩된 경우 해당 데이터를 사용자 JWT에 포함합니다.                                                    |
| **`hooks`**            | 이 필드에 대한 로직을 제어하기 위해 필드 훅을 제공합니다. [자세한 내용](../hooks/fields).                                                                                                  |
| **`access`**           | 사용자가 이 필드의 데이터로 무엇을 보고 할 수 있는지 나타내는 필드 액세스 제어를 제공합니다. [자세한 내용](../access-control/fields).                                                    |
| **`hidden`**           | 모든 API에서 이 필드의 가시성을 완전히 제한합니다. 데이터베이스에는 여전히 저장되지만 API 응답이나 관리자 패널에는 표시되지 않습니다.                                                     |
| **`defaultValue`**     | 이 필드의 기본값으로 사용할 블록 데이터 배열을 제공합니다. [자세한 내용](/docs/fields/overview#default-values).                                                                          |
| **`localized`**        | 이 필드에 대해 현지화를 활성화합니다. 기본 구성에서 [현지화가 활성화](/docs/configuration/localization)되어야 합니다. 활성화되면 이 필드 내의 모든 데이터의 별도 현지화된 세트가 유지되므로 각 중첩 필드를 `localized`로 지정할 필요가 없습니다. |
| **`unique`**           | 컬렉션의 각 항목이 이 필드에 대해 고유한 값을 갖도록 강제합니다.                                                                                                                          |
| **`labels`**           | 관리자 대시보드에 나타나는 블록 행 레이블을 커스터마이징합니다.                                                                                                                           |
| **`admin`**            | 관리자 특정 구성. [자세한 내용](#admin-options).                                                                                                                                          |
| **`custom`**           | 커스텀 데이터 추가를 위한 확장 지점 (예: 플러그인용)                                                                                                                                      |
| **`typescriptSchema`** | JSON 스키마 제공으로 필드 유형 생성을 재정의                                                                                                                                              |
| **`virtual`**          | 데이터베이스에서 필드를 비활성화하려면 `true`를 제공하거나 [관계와 필드를 연결](/docs/fields/relationship#linking-virtual-fields-with-relationships)하기 위해 문자열 경로를 제공합니다. [가상 필드](https://payloadcms.com/blog/learn-how-virtual-fields-can-help-solve-common-cms-challenges) 참조 |

_\* 별표는 필수 속성을 나타냅니다._

## 관리자 옵션

[관리자 패널](../admin/overview)에서 블록 필드의 모양과 동작을 커스터마이징하려면 `admin` 옵션을 사용할 수 있습니다:

```ts
import type { Field } from 'payload'

export const MyBlocksField: Field = {
  // ...
  admin: {
    // highlight-line
    // ...
  },
}
```

블록 필드는 기본 [필드 관리자 Config](./overview#admin-options)의 모든 기본 관리자 옵션을 상속하며, 다음과 같은 추가 옵션이 있습니다:

| 옵션                   | 설명                                                                     |
| ---------------------- | ------------------------------------------------------------------------ |
| **`group`**            | 블록 드로어에서 이 블록을 그룹화하는 데 사용되는 텍스트 또는 현지화 객체. |
| **`initCollapsed`**    | 초기 축소 상태 설정                                                      |
| **`isSortable`**       | 이 값을 `false`로 설정하여 순서 정렬 비활성화                            |
| **`disableBlockName`** | 이 값을 `true`로 설정하여 blockName 필드 숨기기                          |

#### Lexical에서 블록이 렌더링되는 방식 커스터마이징

이 블록을 [Lexical 편집기](/docs/rich-text/overview) 내에서 사용하는 경우 커스텀 컴포넌트를 지정하여 Lexical 편집기 자체에서 블록이 렌더링되는 방식을 커스터마이징할 수도 있습니다.

- `admin.components.Label` - 이 블록의 레이블이 렌더링되는 방식을 커스터마이징하기 위해 여기에 커스텀 React 컴포넌트를 전달합니다
- `admin.components.Block` - Lexical에서 블록이 렌더링되는 방식을 자체 컴포넌트로 완전히 재정의하기 위해 여기에 컴포넌트를 전달합니다

이는 편집자에게 리치 텍스트에서 매우 의도적이고 잘 디자인된 블록 "미리보기"를 제시하고 싶을 때 매우 유용합니다.

예를 들어, `gallery` 블록이 있는 경우 Lexical 블록에서 실제로 이미지 갤러리를 직접 렌더링하고 싶을 수 있습니다. `admin.components.Block` 속성을 사용하면 정확히 그렇게 할 수 있습니다!

<Banner type="success">
  **팁:** Lexical에서 블록이 렌더링되는 방식을 커스터마이징하는 경우
  유틸리티 컴포넌트를 가져와서 블록을 쉽게 편집/제거할 수 있으므로
  이 모든 것을 직접 빌드할 필요가 없습니다.
</Banner>

커스텀 블록 중 하나에 대해 이러한 유틸리티 컴포넌트를 가져오려면 다음을 가져올 수 있습니다:

```ts
import {
  // 블록 편집 버튼 (사용법에 해당하는 것을 선택)
  // 클릭하면 블록의 필드가 있는 드로어가 열려
  // 편집자가 편집할 수 있습니다
  InlineBlockEditButton,
  BlockEditButton,

  // Lexical에서 이 블록을 제거할 버튼
  // (사용법에 해당하는 것을 선택)
  InlineBlockRemoveButton,
  BlockRemoveButton,

  // 인라인 블록에 렌더링되어야 하는 레이블
  InlineBlockLabel,

  // 재사용하려는 경우 인라인 블록에 렌더링되는
  // 기본 "컨테이너"
  InlineBlockContainer,

  // 재사용하려는 경우 일반 블록에 렌더링되는
  // 기본 "축소 가능한" UI
  BlockCollapsible,
} from '@payloadcms/richtext-lexical/client'
```

## 블록 구성

블록은 자체적인 별도 구성으로 정의됩니다.

<Banner type="success">
  **팁:** 모범 사례는 각 블록 구성을 자체 파일에 정의한 다음
  필요에 따라 블록 필드로 가져오는 것입니다. 이렇게 하면 각 블록
  구성을 필드 간에 쉽게 공유할 수 있습니다. 예를 들어, "레이아웃
  빌더" 예제를 사용하면 Page 컬렉션뿐만 아니라 Post 컬렉션에서도
  동일한 블록 중 몇 개를 특징으로 하고 싶을 수 있습니다. 자체 파일로
  추상화하면 재사용성이 간소화됩니다.
</Banner>

| 옵션                       | 설명                                                                                                                                                                   |
| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`slug`** \*              | 이 블록 유형의 식별자. 각 블록에 `blockType` 속성으로 저장됩니다.                                                                                                       |
| **`fields`** \*            | 이 블록에 저장될 필드 배열.                                                                                                                                            |
| **`labels`**               | 관리자 대시보드에 나타나는 블록 레이블을 커스터마이징합니다. 정의되지 않은 경우 slug에서 자동 생성됩니다.                                                              |
| **`imageURL`**             | 편집자가 관리자 UI에서 이 블록을 식별하는 데 도움이 되는 커스텀 이미지 썸네일을 제공합니다.                                                                            |
| **`imageAltText`**         | 이 블록의 이미지 썸네일 alt 텍스트를 커스터마이징합니다.                                                                                                               |
| **`interfaceName`**        | 최상위 수준의 재사용 가능한 [TypeScript 인터페이스](/docs/typescript/generating-types#custom-field-interfaces) 및 [GraphQL 유형](/docs/graphql/graphql-schema#custom-field-schemas) 생성. |
| **`graphQL.singularName`** | GraphQL 스키마 이름에 사용할 텍스트. 정의되지 않은 경우 slug에서 자동 생성됩니다. 참고: 이는 더 이상 사용되지 않도록 설정되어 있으며 `interfaceName`을 선호합니다.       |
| **`dbName`**               | SQL 데이터베이스 어댑터([Postgres](/docs/database/postgres))를 사용할 때 이 블록 유형에 대한 커스텀 테이블 이름. 정의되지 않은 경우 slug에서 자동 생성됩니다.          |
| **`custom`**               | 커스텀 데이터 추가를 위한 확장 지점 (예: 플러그인용)                                                                                                                    |

### 블록당 자동 생성 데이터

각 블록에서 정의하는 필드 데이터 외에도 Payload는 각 블록에 두 개의 추가 속성을 저장합니다:

**`blockType`**

`blockType`은 선택된 블록의 slug로 저장됩니다.

**`blockName`**

관리자 패널은 각 블록에 `blockName` 필드를 제공하여 편집자가 더 나은 편집 가능성과 가독성을 위해 블록에 레이블을 지정할 수 있도록 선택적으로 허용합니다. 이는 `admin.disableBlockName`을 통해 시각적으로 숨길 수 있습니다.

## 예제

`collections/ExampleCollection.js`

```ts
import { Block, CollectionConfig } from 'payload'

const QuoteBlock: Block = {
  slug: 'Quote', // 필수
  imageURL: 'https://google.com/path/to/image.jpg',
  imageAltText: '이 블록이 어떻게 보이는지 보여주는 멋진 썸네일 이미지',
  interfaceName: 'QuoteBlock', // 선택사항
  fields: [
    // 필수
    {
      name: 'quoteHeader',
      type: 'text',
      required: true,
    },
    {
      name: 'quoteText',
      type: 'text',
    },
  ],
}

export const ExampleCollection: CollectionConfig = {
  slug: 'example-collection',
  fields: [
    {
      name: 'layout', // 필수
      type: 'blocks', // 필수
      minRows: 1,
      maxRows: 20,
      blocks: [
        // 필수
        QuoteBlock,
      ],
    },
  ],
}
```

## 커스텀 컴포넌트

### 필드

#### 서버 컴포넌트

```tsx
import type React from 'react'
import { BlocksField } from '@payloadcms/ui'
import type { BlocksFieldServerComponent } from 'payload'

export const CustomBlocksFieldServer: BlocksFieldServerComponent = ({
  clientField,
  path,
  schemaPath,
  permissions,
}) => {
  return (
    <BlocksField
      field={clientField}
      path={path}
      schemaPath={schemaPath}
      permissions={permissions}
    />
  )
}
```

#### 클라이언트 컴포넌트

```tsx
'use client'
import React from 'react'
import { BlocksField } from '@payloadcms/ui'
import type { BlocksFieldClientComponent } from 'payload'

export const CustomBlocksFieldClient: BlocksFieldClientComponent = (props) => {
  return <BlocksField {...props} />
}
```

### 레이블

#### 서버 컴포넌트

```tsx
import React from 'react'
import { FieldLabel } from '@payloadcms/ui'
import type { BlocksFieldLabelServerComponent } from 'payload'

export const CustomBlocksFieldLabelServer: BlocksFieldLabelServerComponent = ({
  clientField,
  path,
}) => {
  return (
    <FieldLabel
      label={clientField?.label || clientField?.name}
      path={path}
      required={clientField?.required}
    />
  )
}
```

#### 클라이언트 컴포넌트

```tsx
'use client'
import React from 'react'
import { FieldLabel } from '@payloadcms/ui'
import type { BlocksFieldLabelClientComponent } from 'payload'

export const CustomBlocksFieldLabelClient: BlocksFieldLabelClientComponent = ({
  label,
  path,
  required,
}) => {
  return (
    <FieldLabel
      label={field?.label || field?.name}
      path={path}
      required={field?.required}
    />
  )
}
```

### 행 레이블

```tsx
'use client'

import { useRowLabel } from '@payloadcms/ui'

export const BlockRowLabel = () => {
  const { data, rowNumber } = useRowLabel<{ title?: string }>()

  const customLabel = `${data.type} ${String(rowNumber).padStart(2, '0')} `

  return <div>커스텀 레이블: {customLabel}</div>
}
```

## 블록 참조

여러 장소에서 사용되는 여러 블록이 있는 경우 Payload Config의 크기가 커져서 잠재적으로 클라이언트에 더 많은 데이터를 보내고 서버에서 더 많은 처리가 필요할 수 있습니다. 그러나 Payload Config에서 각 블록을 **한 번** 정의한 다음 전체 블록 구성을 전달하는 대신 사용되는 곳마다 해당 slug를 참조하여 성능을 최적화할 수 있습니다.

이렇게 하려면 Payload Config의 `blocks` 배열에 블록을 정의합니다. 그런 다음 블록 필드에서 블록 slug를 `blockReferences` 배열에 전달하고 호환성을 위해 `blocks` 배열을 비워둡니다.

```ts
import { buildConfig } from 'payload'
import { lexicalEditor, BlocksFeature } from '@payloadcms/richtext-lexical'

// Payload Config
const config = buildConfig({
  // 블록을 한 번 정의
  blocks: [
    {
      slug: 'TextBlock',
      fields: [
        {
          name: 'text',
          type: 'text',
        },
      ],
    },
  ],
  collections: [
    {
      slug: 'collection1',
      fields: [
        {
          name: 'content',
          type: 'blocks',
          // slug로 블록 참조
          blockReferences: ['TextBlock'],
          blocks: [], // 호환성을 위해 비어 있어야 함
        },
      ],
    },
    {
      slug: 'collection2',
      fields: [
        {
          name: 'editor',
          type: 'richText',
          editor: lexicalEditor({
            features: [
              BlocksFeature({
                // 성능 저하 없이 동일한 참조를 lexical 편집기에서도 어디든 재사용할 수 있음
                blocks: ['TextBlock'],
              }),
            ],
          }),
        },
      ],
    },
  ],
})
```

<Banner type="warning">
  **알림:**
  `blockReferences` 배열에서 참조되는 블록은 컬렉션/글로벌 구성에서 격리된 것으로 처리됩니다. 이는 다음과 같은 의미를 갖습니다:

1. 블록 구성은 컬렉션 구성에서 수정하거나 확장할 수 없습니다. 참조되는 모든 곳에서 동일할 것입니다.
2. `blockReferences`에서 참조되는 블록에 대한 액세스 제어는 한 번만 실행됩니다. 컬렉션의 데이터는 블록의 액세스 제어에서 사용할 수 없습니다.
</Banner>

## TypeScript

자체 블록 구성을 빌드할 때 별도 파일에 저장하고 싶지만 그에 따라 타이핑을 유지하고 싶을 수 있습니다. 이렇게 하려면 Payload의 `Block` 유형을 가져와서 사용할 수 있습니다:

```ts
import type { Block } from 'payload'
```