---
title: 쿠키 전략
label: 쿠키 전략
order: 40
desc: HTTP 쿠키 기반 인증을 활성화하여 Payload와 인터페이스하세요.
keywords: 인증, 구성, 설정, 문서, 콘텐츠 관리 시스템, cms, 헤드리스, javascript, node, react, nextjs
---

Payload는 HTTP 전용 쿠키를 통한 [인증](./overview) 기능을 제공합니다. 이러한 쿠키는 `login`, `logout`, `refresh`, `me` 인증 작업의 응답에서 읽을 수 있습니다.

<Banner type="success">
  **팁:** [접근 제어](../access-control/overview)와 [훅](../hooks/overview) 내에서
  `req.user` 인수를 통해 로그인한 사용자에 접근할 수 있습니다. [자세한
  내용](./token-data).
</Banner>

### 자동 브라우저 포함

최신 브라우저는 URL에 직접 요청을 할 때 `http-only` 쿠키를 자동으로 포함합니다. 즉, `https://example.com`에서 API를 실행하고 있고 로그인하여 `https://example.com/test-page`를 방문하면, 브라우저가 자동으로 Payload 인증 쿠키를 포함시켜 줍니다.

### HTTP 인증

하지만 `fetch`나 유사한 API를 사용하여 Payload의 REST 또는 GraphQL API에서 리소스를 검색하는 경우, 자격 증명(쿠키)을 포함하도록 명시해야 합니다.

자격 증명을 포함한 Fetch 예제:

```ts
const response = await fetch('http://localhost:3000/api/pages', {
  credentials: 'include',
})

const pages = await response.json()
```

앱에서 Payload API로의 요청에 쿠키를 포함하는 방법에 대한 자세한 내용은 [MDN 문서](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Sending_a_request_with_credentials_included)를 참조하세요.

<Banner type="success">
  **팁:** 로그인 후 브라우저에서 Payload 쿠키가 제대로 설정되었는지 확인하려면
  브라우저의 개발자 도구 > Application > Cookies > [your-domain-here]를 사용할
  수 있습니다. 개발자 도구는 여전히 HTTP 전용 쿠키를 표시합니다.
</Banner>

### CSRF 공격

CSRF(cross-site request forgery) 공격은 일반적이고 위험합니다. HTTP 전용 쿠키를 사용함으로써 Payload는 많은 XSS 취약점을 제거하지만, CSRF 공격은 여전히 가능할 수 있습니다.

예를 들어, 사용자가 금융을 관리하고 송금과 수신을 할 수 있는 인기 앱 `https://payload-finances.com`이 있다고 가정해봅시다. Payload가 HTTP 전용 쿠키를 사용하고 있기 때문에, 브라우저는 **어떤 페이지가 요청을 생성했는지에 관계없이** 귀하의 도메인으로 요청을 보낼 때 쿠키를 자동으로 포함합니다.

따라서 `https://payload-finances.com`의 사용자가 로그인한 상태에서 인터넷을 브라우징하다가 악의적인 의도를 가진 페이지를 접할 수 있습니다. 예를 살펴보겠습니다:

```ts
// malicious-intent.com
// 사용자를 대신하여 인증된 요청을 수행

const maliciousRequest = await fetch(`https://payload-finances.com/api/me`, {
  credentials: 'include',
}).then((res) => await res.json())
```

이 시나리오에서, 쿠키가 여전히 유효하다면, malicious-intent.com은 위와 같은 요청을 사용자를 대신하여 만들 수 있습니다. 이것이 CSRF 공격입니다.

### CSRF 예방

Payload HTTP 전용 쿠키 기반 요청을 수락할 의사가 있고 신뢰하는 도메인을 정의하세요. 기본 Payload Config에서 `csrf` 옵션을 사용하여 이를 수행하세요:

```ts
// payload.config.ts

import { buildConfig } from 'payload'

const config = buildConfig({
  serverURL: 'https://my-payload-instance.com',
  // highlight-start
  csrf: [
    // 쿠키 인증을 허용할 도메인 화이트리스트
    'https://your-frontend-app.com',
    'https://your-other-frontend-app.com',
    // 정의된 경우 `config.serverURL`이 기본적으로 추가됨
  ],
  // highlight-end
  collections: [
    // 컬렉션들
  ],
})

export default config
```

#### 도메인 간 인증

프론트엔드가 Payload API와 다른 도메인에 있다면, 브라우저에서 타사 쿠키로 간주되어 기본적으로 HTTP 전용 쿠키를 인증에 사용할 수 없습니다.
이를 해결하는 몇 가지 전략이 있습니다:

##### 1. 서브도메인 사용

쿠키는 타사 쿠키로 간주되지 않고 서브도메인 간 이동할 수 있습니다. 예를 들어 API가 api.example.com에 있다면 example.com에서 인증할 수 있습니다.

##### 2. 쿠키 구성

옵션 1이 불가능한 경우, 인증 컬렉션에서 [쿠키를 구성](./overview#config-options)하여 다음 설정을 달성함으로써 이 제한을 해결할 수 있습니다:

```
SameSite: None // 쿠키가 도메인을 넘나들 수 있도록 허용
Secure: true // HTTPS를 통해서만 전송되도록 보장
HttpOnly: true // 클라이언트 측 JavaScript를 통해 접근할 수 없도록 보장
```

구성 예제:

```ts
{
  slug: 'users',
  auth: {
    cookies: {
      sameSite: 'None',
      secure: true,
    }
  },
  fields: [
    // 인증 필드들
  ]
},
```

Payload 구성에서 [cors](../production/preventing-abuse#cross-origin-resource-sharing-cors)를 구성하는 경우, 더 이상 와일드카드를 사용할 수 없으며 허용된 도메인 목록을 명시해야 합니다.

<Banner type="success">
  **알아두면 좋은 점:** `secure: true`를 설정하면 `http://localhost`나 다른
  비https 도메인에서 개발할 때 작동하지 않습니다. 로컬 개발의 경우 환경에
  따라 조건부로 `false`로 설정해야 합니다.
</Banner>