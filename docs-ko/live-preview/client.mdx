---
title: 클라이언트 측 라이브 미리보기
label: 클라이언트 측
order: 40
desc: 클라이언트 측 프론트엔드 애플리케이션에서 라이브 미리보기를 구현하는 방법을 알아보세요.
keywords: live preview, frontend, react, next.js, vue, nuxt.js, svelte, hook, useLivePreview
---

<Banner type="info">
  프론트엔드 애플리케이션이 [Next.js App
  Router](https://nextjs.org/docs/app)와 같은 서버 컴포넌트를 지원한다면,
  대신 [서버 측 라이브 미리보기](./server)를 설정하는 것을 권장합니다.
</Banner>

라이브 미리보기를 사용하는 동안 [관리자 패널](../admin/overview)은 문서가 변경될 때마다 새로운 `window.postMessage` 이벤트를 발생시킵니다. 프론트엔드 애플리케이션은 이러한 이벤트를 수신하고 그에 따라 다시 렌더링할 수 있습니다.

프론트엔드 애플리케이션이 [React](#react)나 [Vue](#vue)로 구축된 경우, Payload가 제공하는 `useLivePreview` 훅을 사용하세요. 향후 Svelte와 같은 다른 주요 프레임워크들도 공식적으로 지원될 예정입니다. 현재 이러한 프레임워크를 사용하고 있다면, Payload가 제공하는 기본 도구를 사용하여 직접 라이브 미리보기와 통합할 수 있습니다. 자세한 내용은 [자체 훅 구축](#자체-훅-구축)을 참조하세요.

기본적으로 모든 훅은 다음 인수들을 허용합니다:

| 경로               | 설명                                                                     |
| ------------------ | ------------------------------------------------------------------------ |
| **`serverURL`** \* | Payload 서버의 URL입니다.                                                |
| **`initialData`**  | 문서의 초기 데이터입니다. 변경사항이 있을 때 라이브 데이터가 병합됩니다. |
| **`depth`**        | 가져올 관계의 깊이입니다. 기본값은 `0`입니다.                            |
| **`apiRoute`**     | `routes.api`에서 정의된 API 경로의 경로입니다. 기본값은 `/api`입니다.     |

_\* 별표는 필수 속성을 나타냅니다._

그리고 다음 값들을 반환합니다:

| 경로            | 설명                                              |
| --------------- | ------------------------------------------------- |
| **`data`**      | 초기 데이터와 병합된 문서의 라이브 데이터입니다.  |
| **`isLoading`** | 문서가 로딩 중인지 여부를 나타내는 불린 값입니다. |

<Banner type="info">
  프론트엔드가 필수 필드에 밀접하게 결합되어 있다면, 이러한 필드가 제거될 때
  UI가 깨지지 않도록 해야 합니다. 예를 들어, `data.relatedPosts[0].title`과
  같은 것을 렌더링하는 경우, 첫 번째 관련 게시물을 제거하면 페이지가 깨집니다.
  이를 해결하려면 필요한 곳에서 조건부 로직, 옵셔널 체이닝 또는 기본값을
  UI에서 사용하세요. 예: `data?.relatedPosts?.[0]?.title`.
</Banner>

<Banner type="info">
  `depth` 인수가 초기 페이지 요청의 깊이와 정확히 일치하는 것이 중요합니다.
  depth 속성은 ID를 넘어서 관계와 업로드를 채우는 데 사용됩니다. 자세한 정보는
  [깊이](../queries/depth)를 참조하세요.
</Banner>## 프레임워크

라이브 미리보기는 네이티브 [`window.postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) API를 지원하는 모든 프론트엔드 프레임워크와 작동합니다. 기본적으로 Payload는 다음과 같은 가장 인기 있는 프레임워크들을 공식적으로 지원합니다:

- [React](#react)
- [Vue](#vue)

프레임워크가 목록에 없다면, Payload가 제공하는 기본 도구를 사용하여 라이브 미리보기와 통합할 수 있습니다. [자세한 내용](#자체-훅-구축).

### React

프론트엔드 애플리케이션이 [Next.js Pages Router](https://nextjs.org/docs/pages)와 같은 클라이언트 측 [React](https://react.dev)로 구축된 경우, Payload가 제공하는 `useLivePreview` 훅을 사용할 수 있습니다.

먼저 `@payloadcms/live-preview-react` 패키지를 설치하세요:

```bash
npm install @payloadcms/live-preview-react
```

그런 다음 React 컴포넌트에서 `useLivePreview` 훅을 사용하세요:

```tsx
'use client'
import { useLivePreview } from '@payloadcms/live-preview-react'
import { Page as PageType } from '@/payload-types'

// 서버 컴포넌트에서 페이지를 가져와서 클라이언트 컴포넌트에 전달한 다음 훅을 통해 연결
// 훅이 인계받아 미리보기를 변경사항과 동기화 유지
// `data` 속성에는 문서의 라이브 데이터가 포함됩니다
export const PageClient: React.FC<{
  page: {
    title: string
  }
}> = ({ page: initialPage }) => {
  const { data } = useLivePreview<PageType>({
    initialData: initialPage,
    serverURL: PAYLOAD_SERVER_URL,
    depth: 2,
  })

  return <h1>{data.title}</h1>
}
```

<Banner type="warning">
  **알림:** [React 서버
  컴포넌트](https://react.dev/reference/rsc/server-components)를 사용하고 있다면,
  대신 [서버 측 라이브 미리보기](./server)를 설정하는 것을 강력히 권장합니다.
</Banner>

### Vue

프론트엔드 애플리케이션이 [Vue 3](https://vuejs.org)나 [Nuxt 3](https://nuxt.js)로 구축된 경우, Payload가 제공하는 `useLivePreview` 컴포저블을 사용할 수 있습니다.

먼저 `@payloadcms/live-preview-vue` 패키지를 설치하세요:

```bash
npm install @payloadcms/live-preview-vue
```

그런 다음 Vue 컴포넌트에서 `useLivePreview` 훅을 사용하세요:

```ts
<script setup lang="ts">
import type { PageData } from '~/types';
import { defineProps } from 'vue';
import { useLivePreview } from '@payloadcms/live-preview-vue';

// 부모 컴포넌트에서 또는 비동기 상태를 사용하여 초기 데이터를 가져옵니다
const props = defineProps<{ initialData: PageData }>();

// 훅이 여기서 인계받아 미리보기를 변경사항과 동기화 유지합니다.
// `data` 속성에는 관리 UI의 미리보기 뷰에서 볼 때만 문서의 라이브 데이터가 포함됩니다.
const { data } = useLivePreview<PageData>({
  initialData: props.initialData,
  serverURL: "<PAYLOAD_SERVER_URL>",
  depth: 2,
});
</script>

<template>
  <h1>{{ data.title }}</h1>
</template>
```

## 자체 훅 구축

어떤 프론트엔드 프레임워크를 사용하든, Payload가 제공하는 동일한 기본 도구를 사용하여 자체 훅을 구축할 수 있습니다.

먼저 기본 `@payloadcms/live-preview` 패키지를 설치하세요:

```bash
npm install @payloadcms/live-preview
```

이 패키지는 다음 함수들을 제공합니다:

| 경로                     | 설명                                                                                                 |
| ------------------------ | ---------------------------------------------------------------------------------------------------- |
| **`subscribe`**          | 관리자 패널의 `window.postMessage` 이벤트를 구독하고 제공된 콜백 함수를 호출합니다.                 |
| **`unsubscribe`**        | 관리자 패널의 `window.postMessage` 이벤트 구독을 해제합니다.                                         |
| **`ready`**              | 프론트엔드가 메시지를 받을 준비가 되었음을 관리자 패널에 알리는 `window.postMessage` 이벤트를 보냅니다. |
| **`isLivePreviewEvent`** | `MessageEvent`가 관리자 패널에서 발생하며 라이브 미리보기 이벤트인지, 즉 디바운스된 폼 상태인지 확인합니다. |

`subscribe` 함수는 다음 인수들을 받습니다:

| 경로               | 설명                                                                            |
| ------------------ | ------------------------------------------------------------------------------- |
| **`callback`** \*  | 문서에 변경이 있을 때마다 `data`와 함께 호출되는 콜백 함수입니다.               |
| **`serverURL`** \* | Payload 서버의 URL입니다.                                                       |
| **`initialData`**  | 문서의 초기 데이터입니다. 변경사항이 있을 때 라이브 데이터가 병합됩니다.        |
| **`depth`**        | 가져올 관계의 깊이입니다. 기본값은 `0`입니다.                                   |

이 함수들로 원하는 프론트엔드 프레임워크를 사용하여 자체 훅을 구축할 수 있습니다:

```tsx
import { subscribe, unsubscribe } from '@payloadcms/live-preview'

// 자체 훅을 구축하려면 `subscribe` 함수를 사용하여 라이브 미리보기 이벤트를 구독하세요
// 다음을 포함한 모든 것을 처리합니다:
// 1. `window.postMessage` 이벤트 수신
// 2. 초기 데이터와 활성 폼 상태 병합
// 3. 관계 및 업로드 채우기
// 4. 결과와 함께 `onChange` 콜백 호출
// 훅은 또한 다음을 수행해야 합니다:
// 1. 관리자 패널에 메시지를 받을 준비가 되었음을 알리기
// 2. `onChange` 콜백의 결과를 처리하여 UI 업데이트
// 3. 언마운트 시 `window.postMessage` 이벤트 구독 해제
```

다음은 위의 동일한 `useLivePreview` React 훅이 내부적으로 어떻게 생겼는지의 예시입니다:

```tsx
import { subscribe, unsubscribe, ready } from '@payloadcms/live-preview'
import { useCallback, useEffect, useState, useRef } from 'react'

export const useLivePreview = <T extends any>(props: {
  depth?: number
  initialData: T
  serverURL: string
}): {
  data: T
  isLoading: boolean
} => {
  const { depth = 0, initialData, serverURL } = props
  const [data, setData] = useState<T>(initialData)
  const [isLoading, setIsLoading] = useState<boolean>(true)
  const hasSentReadyMessage = useRef<boolean>(false)

  const onChange = useCallback((mergedData) => {
    // 변경이 발생하면 `onChange` 콜백이 병합된 데이터와 함께 호출됩니다
    // 이 병합된 데이터를 상태에 설정하여 React가 UI를 다시 렌더링하도록 합니다
    setData(mergedData)
    setIsLoading(false)
  }, [])

  useEffect(() => {
    // 관리자 패널의 `window.postMessage` 이벤트를 수신합니다
    // 변경이 발생하면 `onChange` 콜백이 병합된 데이터와 함께 호출됩니다
    const subscription = subscribe({
      callback: onChange,
      depth,
      initialData,
      serverURL,
    })

    // 구독 후, 관리자 패널에 `ready` 메시지를 다시 전송합니다
    // 이것은 프론트엔드가 메시지를 받을 준비가 되었음을 나타냅니다
    if (!hasSentReadyMessage.current) {
      hasSentReadyMessage.current = true

      ready({
        serverURL,
      })
    }

    // 컴포넌트가 언마운트될 때 `window.postMessage` 이벤트 구독을 해제합니다
    return () => {
      unsubscribe(subscription)
    }
  }, [serverURL, onChange, depth, initialData])

  return {
    data,
    isLoading,
  }
}
```

<Banner type="info">
  자체 훅을 구축할 때는 인수와 반환 값이 이 문서 상단에 나열된 것과
  일치하는지 확인하세요. 이렇게 하면 모든 훅이 동일한 API를 따르게 됩니다.
</Banner>## 예시

이에 대한 작동 데모는 공식 [라이브 미리보기 예시](https://github.com/payloadcms/payload/tree/main/examples/live-preview)를 확인하세요. 거기서 Payload와 동일한 서버에서 실행되는 완전히 통합된 Next.js App Router 프론트엔드의 예시를 찾을 수 있습니다.

## 문제 해결

#### 관계 및/또는 업로드가 채워지지 않음

프론트엔드 애플리케이션에서 관계나 업로드를 사용하고 있고, 프론트엔드 애플리케이션이 Payload 서버와 다른 도메인에서 실행되고 있다면, 두 도메인 간에 요청이 이루어질 수 있도록 [CORS](../configuration/overview#cors)를 구성해야 할 수 있습니다. 여기에는 다른 포트나 하위 도메인에서 실행되는 사이트도 포함됩니다. 마찬가지로, 사용자 인증 뒤에 리소스를 보호하고 있다면, 두 도메인 간에 쿠키가 전송될 수 있도록 [CSRF](../authentication/cookies#csrf-prevention)도 구성해야 할 수 있습니다. 예를 들어:

```ts
// payload.config.ts
{
  // ...
  // 사이트가 Payload 서버와 다른 도메인에서 실행되는 경우,
  // 이것은 두 도메인 간에 요청이 이루어질 수 있도록 허용합니다
  cors: [
    'http://localhost:3001' // 프론트엔드 애플리케이션
  ],
  // 사용자 인증 뒤에 리소스를 보호하고 있는 경우,
  // 이것은 두 도메인 간에 쿠키가 전송될 수 있도록 허용합니다
  csrf: [
    'http://localhost:3001' // 프론트엔드 애플리케이션
  ],
}
```

#### 문서 편집 후 관계 및/또는 업로드가 사라짐

초기 요청과 `useLivePreview` 훅에서 부적절한 [`depth`](../queries/depth)를 설정하고 있거나, 두 값이 일치하지 않을 가능성이 있습니다. `depth` 매개변수가 올바른 값으로 설정되어 있고, 두 곳에서 정확히 일치하는지 확인하세요. 예를 들어:

```tsx
// 초기 요청
const { docs } = await payload.find({
  collection: 'pages',
  depth: 1, // 애플리케이션에 적합한 깊이로 설정되어 있는지 확인
  where: {
    slug: {
      equals: 'home',
    },
  },
})
```

```tsx
// 훅
const { data } = useLivePreview<PageType>({
  initialData: initialPage,
  serverURL: PAYLOAD_SERVER_URL,
  depth: 1, // 초기 요청의 깊이와 일치하는지 확인
})
```

#### iframe이 연결을 거부함

프론트엔드 애플리케이션이 관리자 패널이 프론트엔드 애플리케이션을 로드하는 것을 차단하는 [콘텐츠 보안 정책](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) (CSP)을 설정한 경우, iframe이 사이트를 로드할 수 없습니다. 이를 해결하려면 `frame-ancestors` 지시문을 설정하여 CSP에서 관리자 패널의 도메인을 화이트리스트에 추가할 수 있습니다:

```plaintext
frame-ancestors: "self" localhost:* https://your-site.com;
```