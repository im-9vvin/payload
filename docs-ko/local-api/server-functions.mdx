---
title: 서버 함수와 함께 로컬 API 작업 사용하기
label: 서버 함수
order: 30
desc: Payload에서 서버 함수와 함께 로컬 API 작업을 사용하여 CMS 내에서 직접 서버 측 로직, 데이터 상호작용 및 사용자 정의 워크플로우를 관리하는 방법을 알아보세요.
keywords: server functions, local API, Payload, CMS, server-side logic, custom workflows, data management, headless CMS, TypeScript, Node.js, backend
---

Next.js에서 **서버 함수**(이전에 **서버 액션**이라고 불림)는 서버에서만 실행되는 특별한 함수로, 프론트엔드에서 호출할 수 있으면서도 안전한 백엔드 로직 실행을 가능하게 합니다. 이 함수들은 클라이언트와 서버 간의 격차를 해소하여, 민감한 로직을 노출하지 않고도 프론트엔드 컴포넌트가 백엔드 작업을 수행할 수 있도록 합니다.

### 왜 서버 함수를 사용하는가?

- **프론트엔드에서 백엔드 로직 실행**: 로컬 API는 서버 환경용으로 설계되었으며 클라이언트 측 코드에서 직접 액세스할 수 없습니다. 서버 함수는 프론트엔드 컴포넌트가 백엔드 작업을 안전하게 트리거할 수 있게 합니다.
- **보안상의 이점**: 전체 REST나 GraphQL API를 노출하는 대신, 서버 함수는 필요한 작업에만 액세스를 제한하여 잠재적인 보안 위험을 줄입니다.
- **성능 최적화**: Next.js는 서버 함수를 효율적으로 처리하여, 기존 API 호출에 비해 캐싱, 최적화된 데이터베이스 쿼리, 네트워크 오버헤드 감소와 같은 이점을 제공합니다.
- **간소화된 개발 워크플로우**: 인증 및 권한 부여 검사가 포함된 전체 API 라우트를 설정하는 대신, 서버 함수는 필요한 작업의 가벼우면서도 직접적인 실행을 허용합니다.

### 언제 서버 함수를 사용하는가

프론트엔드에서 로컬 API 작업을 호출해야 할 때마다 서버 함수를 사용하세요. 로컬 API는 백엔드에서만 액세스할 수 있으므로, 서버 함수는 추가 API 엔드포인트를 노출할 필요 없이 안전한 브리지 역할을 합니다.

## 예시

모든 로컬 API 작업은 서버 함수 내에서 사용할 수 있으며, Payload의 백엔드와 안전하게 상호작용할 수 있습니다.

사용 가능한 작업의 전체 목록은 [로컬 API](https://payloadcms.com/docs/local-api/overview) 개요를 참조하세요.

다음 예시에서는 다음과 같은 몇 가지 일반적인 사용 사례를 다루겠습니다:

- 문서 생성
- 문서 업데이트
- 문서 생성 또는 업데이트 시 파일 업로드 처리
- 사용자 인증### 문서 생성

먼저 서버 함수를 생성해보겠습니다. 이 프로세스의 핵심 포인트는 다음과 같습니다:

- 파일 상단에 `'use server'`를 추가하는 것으로 시작합니다.
- `getPayload()`와 같은 유틸리티는 여전히 사용할 수 있습니다.
- 함수 구조가 준비되면, 로컬 API 작업 `payload.create()`를 호출하고 관련 데이터를 전달합니다.
- 오류 처리를 위해 이를 `try...catch` 블록으로 래핑하는 것이 좋은 관행입니다.
- 마지막으로 생성된 문서를 반환해야 합니다(단순히 작업만 실행하지 마세요).

```ts
'use server'

import { getPayload } from 'payload'
import config from '@payload-config'

export async function createPost(data) {
  const payload = await getPayload({ config })

  try {
    const post = await payload.create({
      collection: 'posts',
      data,
    })
    return post
  } catch (error) {
    throw new Error(`Error creating post: ${error.message}`)
  }
}
```

이제 사용자가 버튼을 클릭했을 때 React 컴포넌트에서 프론트엔드에서 방금 만든 `createPost` 함수를 호출하는 방법을 살펴보겠습니다:

```ts
'use client';

import React, { useState } from 'react';
import { createPost } from '../server/actions'; // 서버 함수 가져오기

export const PostForm: React.FC = () => {
  const [result, setResult] = useState<string>('');

  return (
    <>
      <p>{result}</p>

      <button
        type="button"
        onClick={async () => {
          // 서버 함수 호출
          const newPost = await createPost({ title: 'Sample Post' });
          setResult('Post created: ' + newPost.title);
        }}
      >
        Create Post
      </button>
    </>
  );
};
```

### 문서 업데이트

이전 예시의 핵심 포인트들이 여기에도 적용됩니다.

문서를 생성하는 대신 업데이트하려면, 관련 데이터와 **문서 ID를 전달하여** `payload.update()`를 사용합니다.

서버 함수는 다음과 같이 보일 것입니다:

```ts
'use server'

import { getPayload } from 'payload'
import config from '@payload-config'

export async function updatePost(id, data) {
  const payload = await getPayload({ config })

  try {
    const post = await payload.update({
      collection: 'posts',
      id, // 문서 id가 필요합니다
      data,
    })
    return post
  } catch (error) {
    throw new Error(`Error updating post: ${error.message}`)
  }
}
```

프론트엔드 React 컴포넌트에서 `updatePost` 함수를 호출하는 방법은 다음과 같습니다:

```ts
'use client';

import React, { useState } from 'react';
import { updatePost } from '../server/actions'; // 서버 함수 가져오기

export const UpdatePostForm: React.FC = () => {
  const [result, setResult] = useState<string>('');

  return (
    <>
      <p>{result}</p>

      <button
        type="button"
        onClick={async () => {
          // 서버 함수를 호출하여 게시물 업데이트
          const updatedPost = await updatePost('your-post-id-123', { title: 'Updated Post' });
          setResult('Post updated: ' + updatedPost.title);
        }}
      >
        Update Post
      </button>
    </>
  );
};

```

### 사용자 인증

이 예시에서는 Payload의 인증 시스템을 사용하여 사용자가 인증되었는지 확인합니다. 작동 방식은 다음과 같습니다:

- 먼저 `next/headers`의 headers 함수를 사용하여 요청 헤더를 검색합니다.
- 다음으로 이 헤더들을 `payload.auth()`에 전달하여 사용자의 인증 세부 정보를 가져옵니다.
- 사용자가 인증된 경우, 해당 정보가 반환됩니다. 그렇지 않으면 인증되지 않은 경우를 적절히 처리합니다.

사용자를 인증하는 서버 함수는 다음과 같습니다:

```ts
'use server'

import { headers as getHeaders } from 'next/headers'
import config from '@payload-config'
import { getPayload } from 'payload'

export const authenticateUser = async () => {
  const payload = await getPayload({ config })
  const headers = await getHeaders()
  const { user } = await payload.auth({ headers })

  if (user) {
    return { hello: user.email }
  }

  return { hello: 'Not authenticated' }
}
```

프론트엔드에서 인증 서버 함수를 호출하여 테스트하는 기본 예시는 다음과 같습니다:

```ts
'use client';

import React, { useState } from 'react';

import { authenticateUser } from '../server/actions'; // 서버 함수 가져오기

export const AuthComponent: React.FC = () => {
  const [userInfo, setUserInfo] = useState<string>('');


  return (
    <React.Fragment>
      <p>{userInfo}</p>

      <button
        onClick={async () => {
          // 서버 함수를 호출하여 사용자 인증
          const result = await authenticateUser();
          setUserInfo(result.hello);
        }}
        type="button"
      >
        Check Authentication
      </button>
    </React.Fragment>
  );
};
```### 파일 업로드와 함께 문서 생성

이 예시는 파일 업로드와 함께 문서를 생성하는 서버 함수를 작성하는 방법을 보여줍니다. 주요 단계는 다음과 같습니다:

- 두 인수를 전달합니다: 문서 내용을 위한 **data**와 파일을 위한 **upload**
- 업로드 파일을 미디어 필드로 문서 데이터에 병합
- `payload.create()`를 사용하여 문서 데이터와 파일을 모두 포함한 새 게시물 문서 생성

```ts
'use server'

import { getPayload } from 'payload'
import config from '@payload-config'

export async function createPostWithUpload(data, upload) {
  const payload = await getPayload({ config })

  try {
    // 파일과 함께 데이터 준비
    const postData = {
      ...data,
      media: upload,
    }

    const post = await payload.create({
      collection: 'posts',
      data: postData,
    })

    return post
  } catch (error) {
    throw new Error(`Error creating post: ${error.message}`)
  }
}
```

방금 만든 서버 함수를 프론트엔드 컴포넌트에서 사용하여 사용자가 파일 업로드와 함께 게시물을 제출할 수 있도록 하는 방법은 다음과 같습니다:

- 사용자가 게시물 제목을 입력하고 업로드할 파일을 선택합니다.
- 폼이 제출되면, `handleSubmit` 함수가 파일이 선택되었는지 확인합니다.
- 파일이 선택된 경우, 제목과 파일을 모두 `createPostWithFile` 서버 함수에 전달합니다.
- 완료되었습니다!

```ts
'use client';

import React, { useState } from 'react';
import { createPostWithUpload } from '../server/actions';

export const PostForm: React.FC = () => {
  const [title, setTitle] = useState<string>('');
  const [file, setFile] = useState<File | null>(null);
  const [result, setResult] = useState<string>('');

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files) {
      setFile(e.target.files[0]);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!file) {
      setResult('Please upload a file.');
      return;
    }

    try {
      // 서버 함수를 호출하여 파일과 함께 게시물 생성
      const newPost = await createPostWithUpload({ title }, file);
      setResult('Post created with file: ' + newPost.title);
    } catch (error) {
      setResult('Error: ' + error.message);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        placeholder="Post Title"
      />
      <input type="file" onChange={handleFileChange} />
      <button type="submit">Create Post</button>
      <p>{result}</p>
    </form>
  );
};
```

## 재사용 가능한 Payload 서버 함수

로컬 API로 인증을 관리하는 것은 쿠키와 토큰을 직접 처리해야 하고, 이것들이 쿠키만 수정하기 때문에 내장된 로그아웃이나 새로 고침 함수가 없어서 까다로울 수 있습니다. 이를 더 쉽게 만들기 위해, 우리는 `login`, `logout`, `refresh`를 바로 사용할 수 있는 서버 함수로 제공합니다. 이들은 기본적인 복잡성을 처리하므로 여러분이 직접 할 필요가 없습니다.

### Login

자격 증명을 확인하고 인증 쿠키를 설정하여 사용자를 로그인시킵니다. 이 함수는 컬렉션 인증 구성에 따라 사용자 이름이나 이메일을 통한 로그인을 허용합니다.

#### `login` 함수 가져오기

```ts
import { login } from '@payloadcms/next/auth'
```

로그인 함수는 클라이언트 컴포넌트에서 가져올 수 없는 Payload 구성이 필요합니다. 이를 해결하기 위해 아래와 같은 간단한 서버 함수를 생성하고 클라이언트에서 호출하세요.

```ts
'use server'

import { login } from '@payloadcms/next/auth'
import config from '@payload-config'

export async function loginAction({
  email,
  password,
}: {
  email: string
  password: string
}) {
  try {
    const result = await login({
      collection: 'users',
      config,
      email,
      password,
    })
    return result
  } catch (error) {
    throw new Error(
      `Login failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
    )
  }
}
```

#### React 클라이언트 컴포넌트에서 로그인

```tsx
'use client'

import { useState } from 'react'
import { loginAction } from '../loginAction'

export default function LoginForm() {
  const [email, setEmail] = useState<string>('')
  const [password, setPassword] = useState<string>('')

  return (
    <form onSubmit={() => loginAction({ email, password })}>
      <label htmlFor="email">Email</label>
      <input
        id="email"
        onChange={(e: ChangeEvent<HTMLInputElement>) =>
          setEmail(e.target.value)
        }
        type="email"
        value={email}
      />
      <label htmlFor="password">Password</label>
      <input
        id="password"
        onChange={(e: ChangeEvent<HTMLInputElement>) =>
          setPassword(e.target.value)
        }
        type="password"
        value={password}
      />
      <button type="submit">Login</button>
    </form>
  )
}
```### Logout

인증 쿠키와 현재 세션을 지워서 현재 사용자를 로그아웃시킵니다.

#### `logout` 함수 가져오기

```ts
import { logout } from '@payloadcms/next/auth'
```

로그인 함수와 마찬가지로, 이제 이 함수에 Payload 구성을 전달해야 하며 이는 클라이언트 컴포넌트에서 수행할 수 없습니다. 아래와 같은 헬퍼 서버 함수를 사용하세요. 모든 세션이 지워지도록 하려면 옵션에서 `allSessions: true`를 설정하고, 로그아웃하지만 현재 세션을 활성 상태로 유지하려면 이를 `false`로 설정하거나 `undefined`로 둘 수 있습니다.

```ts
'use server'

import { logout } from '@payloadcms/next/auth'
import config from '@payload-config'

export async function logoutAction() {
  try {
    return await logout({ allSessions: true, config })
  } catch (error) {
    throw new Error(
      `Logout failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
    )
  }
}
```

#### React 클라이언트 컴포넌트에서 로그아웃

```tsx
'use client'

import { logoutAction } from '../logoutAction'

export default function LogoutButton() {
  return <button onClick={() => logoutFunction()}>Logout</button>
}
```

### Refresh

로그인한 사용자의 인증 토큰과 현재 세션을 새로 고침합니다.

#### `refresh` 함수 가져오기

```ts
import { refresh } from '@payloadcms/next/auth'
```

로그인 및 로그아웃과 마찬가지로, 이 함수에 Payload 구성을 전달해야 합니다. 아래와 같은 헬퍼 서버 함수를 생성하세요. 구성을 클라이언트에 직접 전달하는 것은 불가능하며 오류가 발생합니다.

```ts
'use server'

import { refresh } from '@payloadcms/next/auth'
import config from '@payload-config'

export async function refreshAction() {
  try {
    return await refresh({
      config,
    })
  } catch (error) {
    throw new Error(
      `Refresh failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
    )
  }
}
```

#### React 클라이언트 컴포넌트에서 새로 고침 사용

```tsx
'use client'

import { refreshAction } from '../actions/refreshAction'

export default function RefreshTokenButton() {
  return <button onClick={() => refreshFunction()}>Refresh</button>
}
```

## 서버 함수에서 오류 처리

서버 함수를 사용할 때, 처리되지 않은 예외를 방지하고 프론트엔드에 의미 있는 피드백을 제공하기 위해 적절한 오류 처리가 필수적입니다.

### 최선의 관행#error-handling-best-practices

- 잠재적인 오류를 잡기 위해 로컬 API 호출을 **try/catch 블록**으로 래핑하세요.
- 디버깅 목적으로 서버에서 **오류를 기록**하세요.
- 원시 오류를 프론트엔드에 노출하는 대신 구조화된 **오류 응답**을 반환하세요.

좋은 오류 처리의 예시:

```ts
export async function createPost(data) {
  try {
    const payload = await getPayload({ config })
    return await payload.create({ collection: 'posts', data })
  } catch (error) {
    console.error('Error creating post:', error)
    return { error: 'Failed to create post' }
  }
}
```

## 보안 고려사항

서버 함수를 사용하면 로컬 API 작업이 프론트엔드에 직접 노출되는 것을 방지하는 데 도움이 되지만, 추가적인 보안 모범 사례를 따라야 합니다:

### 최선의 관행#security-best-practices

- **액세스 제한**: 민감한 작업(사용자 관리 등)은 권한이 있는 사용자만 호출할 수 있도록 하세요.
- **민감한 데이터 전달 방지**: 사용자 데이터, 비밀번호 등과 같은 민감한 정보를 반환하지 마세요.
- **인증 및 권한 부여 사용**: 작업을 수행하기 전에 사용자 역할을 확인하세요.

사용자 역할에 기반한 액세스 제한 예시:

```ts
export async function deletePost(postId, user) {
  if (!user || user.role !== 'admin') {
    throw new Error('Unauthorized')
  }

  const payload = await getPayload({ config })
  return await payload.delete({ collection: 'posts', id: postId })
}
```