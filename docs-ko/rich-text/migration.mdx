---
title: Lexical 마이그레이션
label: 마이그레이션
order: 90
desc: slate와 payload-plugin-lexical에서 lexical로 마이그레이션
keywords: lexical, rich text, editor, headless cms, migrate, migration
---

## Slate에서 마이그레이션

Slate와 Lexical 모두 에디터 상태를 JSON으로 저장하지만 JSON의 구조는 다릅니다.

### 마이그레이션 스크립트를 통한 마이그레이션 (권장)

우리가 제공하는 `migrateSlateToLexical` 함수를 가져와서 `payload` 객체를 전달하고 실행하기만 하면 됩니다. 컬렉션의 양에 따라 시간이 좀 걸릴 수 있습니다.

중요: 이는 모든 slate 데이터를 덮어씁니다. 먼저 다음을 수행하는 것이 좋습니다:

1. 전체 데이터베이스 백업을 생성하세요. 문제가 발생하고 백업이 없다면 지원을 받을 수 없습니다.
2. 모든 richText 필드를 lexical 에디터로 만드세요. 이 스크립트는 오래된 Slate 데이터가 있는 lexical richText 필드만 변환합니다.
3. 먼저 SlateToLexicalFeature(아래 참조)를 추가하고 관리자 패널을 로드하여 마이그레이터가 예상대로 작동하는지 테스트해보세요. 커스텀 Slate 노드를 변환하기 위해 먼저 일부 필드에 대한 커스텀 변환기를 구축해야 할 수 있습니다. SlateToLexicalFeature는 변환기가 저장되는 곳입니다. 이 기능이 추가된 필드만 마이그레이션됩니다.
4. 이것이 예상대로 작동한다면 `SlateToLexicalFeature`를 초기화하는 모든 곳에 `disableHooks: true` prop을 추가하세요. 예: `SlateToLexicalFeature({ disableHooks: true })`. 이를 완료하면 마이그레이션 스크립트를 실행할 준비가 됩니다.

```ts
import { migrateSlateToLexical } from '@payloadcms/richtext-lexical/migrate'

await migrateSlateToLexical({ payload })
```

### SlateToLexicalFeature를 통한 마이그레이션

이를 처리하는 한 가지 방법은 lexical 에디터에 slate JSON을 읽을 수 있는 기능을 제공하는 것입니다.

단순히 에디터에 `SlateToLexicalFeature`를 추가하세요:

```ts
import type { CollectionConfig } from 'payload'

import { SlateToLexicalFeature } from '@payloadcms/richtext-lexical/migrate'
import { lexicalEditor } from '@payloadcms/richtext-lexical'

const Pages: CollectionConfig = {
  slug: 'pages',
  fields: [
    {
      name: 'nameOfYourRichTextField',
      type: 'richText',
      editor: lexicalEditor({
        features: ({ defaultFeatures }) => [
          ...defaultFeatures,
          SlateToLexicalFeature({}),
        ],
      }),
    },
  ],
}
```

완료! 이제 이 lexical 에디터가 초기화될 때마다 slate 데이터를 즉석에서 lexical로 변환합니다. 데이터가 이미 lexical 형식이라면 그대로 통과시킵니다.

이것이 Slate에서 Lexical로 마이그레이션하는 가장 쉬운 방법이지만 몇 가지 주의사항이 있습니다:

- lexical 에디터를 초기화할 때 성능 저하가 있습니다
- 즉석 변환기는 관리자 패널에서만 실행되므로 에디터는 여전히 출력 JSON에서 Slate 데이터를 출력합니다

이를 해결하는 쉬운 방법: richText 필드를 편집하고 문서를 저장하세요! 이렇게 하면 slate 데이터가 lexical 데이터로 덮어쓰여지고, 다음에 문서가 로드될 때 lexical 데이터가 사용됩니다. 이는 해당 특정 문서에 대한 성능과 출력 문제를 모두 해결합니다. 그러나 이는 느리고 점진적인 마이그레이션 프로세스이므로 두 API 형식을 모두 지원해야 합니다. 특히 많은 수의 문서에 대해서는 위에서 설명한 대로 마이그레이션 스크립트를 실행하는 것이 좋습니다.

### 커스텀 Slate 노드 변환

커스텀 Slate 노드가 있는 경우 이를 위한 커스텀 변환기를 만드세요. 다음은 예제로 업로드 변환기입니다:

```ts
import type { SerializedUploadNode } from '../uploadNode'
import type { SlateNodeConverter } from '@payloadcms/richtext-lexical'

export const SlateUploadConverter: SlateNodeConverter = {
  converter({ slateNode }) {
    return {
      fields: {
        ...slateNode.fields,
      },
      format: '',
      relationTo: slateNode.relationTo,
      type: 'upload',
      value: {
        id: slateNode.value?.id || '',
      },
      version: 1,
    } as const as SerializedUploadNode
  },
  nodeTypes: ['upload'],
}
```

매우 간단합니다: Slate 노드를 입력으로 받고 lexical 노드를 반환합니다. `nodeTypes` 배열은 이 변환기가 처리할 수 있는 Slate 노드를 결정하는 데 사용됩니다.

마이그레이션 스크립트를 사용할 때 위 예제에서 본 것처럼 `convertSlateToLexical` props의 `converters` 속성에 커스텀 변환기를 추가할 수 있습니다.

`SlateToLexicalFeature`를 사용할 때는 `SlateToLexicalFeature` props의 `converters` 속성에 커스텀 변환기를 추가할 수 있습니다:

```ts
import type { CollectionConfig } from 'payload'

import { lexicalEditor } from '@payloadcms/richtext-lexical'
import {
  SlateToLexicalFeature,
  defaultSlateConverters,
} from '@payloadcms/richtext-lexical'

import { YourCustomConverter } from '../converters/YourCustomConverter'

const Pages: CollectionConfig = {
  slug: 'pages',
  fields: [
    {
      name: 'nameOfYourRichTextField',
      type: 'richText',
      editor: lexicalEditor({
        features: ({ defaultFeatures }) => [
          ...defaultFeatures,
          SlateToLexicalFeature({
            converters: [...defaultSlateConverters, YourCustomConverter],
          }),
        ],
      }),
    },
  ],
}
```

## payload-plugin-lexical에서 마이그레이션

[payload-plugin-lexical](https://github.com/AlessioGr/payload-plugin-lexical)에서 마이그레이션하는 것은 Slate에서 마이그레이션하는 것과 유사합니다.

`SlateToLexicalFeature` 대신 사용할 수 있는 `LexicalPluginToLexicalFeature`가 있습니다. 그리고 `convertSlateToLexical` 대신 `convertLexicalPluginToLexical`을 사용할 수 있습니다.

## 이전 버전에서 새 버전으로 lexical 데이터 마이그레이션

각 lexical 노드에는 데이터베이스에 저장되는 `version` 속성이 있습니다. 노드의 데이터에 중단 변경을 가할 때마다 버전을 증가시킵니다. 이렇게 하면 이전 버전을 감지하고 에디터를 열 때 이전 데이터를 새 형식으로 자동 변환할 수 있습니다.

문제는 이 마이그레이션이 에디터를 열고, richText 필드를 수정하고(필드의 `setValue` 함수가 호출되도록), 문서를 저장할 때만 발생한다는 것입니다. 모든 문서에 대해 이를 수행할 때까지 일부 문서는 여전히 이전 데이터를 갖게 됩니다.

이를 해결하기 위해 Payload 앱의 모든 문서를 검토하고 lexical 에디터가 있으면 다시 저장하는 `upgradeLexicalData` 함수를 내보냅니다. 이렇게 하면 데이터가 자동으로 새 형식으로 변환되고, 그 자동 변환이 앱의 모든 문서에 적용됩니다.

중요: 전체 데이터베이스 백업을 생성하세요. 문제가 발생하고 백업이 없다면 지원을 받을 수 없습니다.

```ts
import { upgradeLexicalData } from '@payloadcms/richtext-lexical'

await upgradeLexicalData({ payload })
```