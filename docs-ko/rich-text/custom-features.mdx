---
title: 커스텀 기능
label: 커스텀 기능
order: 40
desc: 커스텀 기능 구축
keywords: lexical, rich text, editor, headless cms, feature, features
---

Lexical용 커스텀 기능을 구축하기 시작하기 전에 [Lexical 문서](https://lexical.dev/docs/intro), 특히 "Concepts" 섹션을 숙지하는 것이 중요합니다. 이 기초는 노드, 에디터 상태, 명령어와 같은 Lexical의 핵심 원칙을 이해하는 데 필요합니다.

Lexical 기능은 모듈러 방식으로 설계되어 각 기능이 두 개의 특정 인터페이스 내에 캡슐화됩니다: 서버 사이드 코드용과 클라이언트 사이드 코드용입니다.

관례적으로 이들은 서버 사이드 기능을 위해 `feature.server.ts`, 클라이언트 사이드 기능을 위해 `feature.client.ts`로 명명됩니다. 주요 기능은 사용자가 프로젝트에 가져올 `feature.server.ts` 내에 있습니다. 클라이언트 사이드 기능은 별도로 정의되지만 서버 기능을 통해 서버 사이드에서 통합되고 렌더링됩니다.

이렇게 하면 서버와 클라이언트 코드 간에 명확한 경계를 유지하면서도 기능에 필요한 코드를 기본적으로 한 곳에 중앙 집중화할 수 있습니다. 이 접근 방식은 툴바 항목, 버튼 또는 새 노드와 같이 기능을 전체적으로 구성하는 모든 요소들을 관리하는 데 유익하며, 각 기능을 깔끔하게 포함하고 독립적으로 관리할 수 있게 합니다.

<Banner type="warning">
  **중요:**
  코어 lexical 패키지에서 직접 가져오지 마세요 - 이는 Payload 버전의 마이너 업데이트에서 중단될 수 있습니다.

  대신 `@payloadcms/richtext-lexical`에서 다시 내보낸 버전을 가져오세요. 예를 들어, `import { $insertNodeToNearestRoot } from '@lexical/utils'`를 `import { $insertNodeToNearestRoot } from '@payloadcms/richtext-lexical/lexical/utils'`로 변경하세요

</Banner>

## 커스텀 기능이 필요한가요?

커스텀 기능을 구축하기 시작하기 전에 기존의 `BlocksFeature`를 사용하여 원하는 기능을 달성할 수 있는지 고려해보세요. `BlocksFeature`는 커스텀 React 컴포넌트, markdown 변환기 등을 포함한 다양한 옵션으로 커스텀 블록을 만들 수 있는 강력한 기능입니다. `BlocksFeature`를 사용하여 원하는 기능을 달성할 수 있다면 커스텀 기능을 구축하는 대신 이를 사용하는 것이 권장됩니다.

BlocksFeature를 사용하면 에디터에 인라인 블록(= 단락에 삽입할 수 있고 텍스트 사이에 위치)과 블록 블록(= 전체 줄을 차지) 모두를 추가할 수 있습니다. 단순히 커스텀 react 컴포넌트를 에디터에 가져오고 싶다면 이것이 방법입니다.

### 예제: 언어 선택기가 있는 코드 필드 블록

이 예제는 `BlocksFeature`를 사용하여 언어 선택기가 있는 커스텀 코드 필드 블록을 만드는 방법을 보여줍니다. 먼저 프로젝트에서 `@payloadcms/ui`를 명시적으로 설치해야 합니다.

필드 설정:

```ts
import {
  BlocksFeature,
  lexicalEditor,
} from '@payloadcms/richtext-lexical'

export const languages = {
  ts: 'TypeScript',
  plaintext: 'Plain Text',
  tsx: 'TSX',
  js: 'JavaScript',
  jsx: 'JSX',
}

// ...
{
  name: 'richText',
  type: 'richText',
  editor: lexicalEditor({
    features: ({ defaultFeatures }) => [
      ...defaultFeatures,
      BlocksFeature({
        blocks: [
          {
            slug: 'Code',
            fields: [
              {
                type: 'select',
                name: 'language',
                options: Object.entries(languages).map(([key, value]) => ({
                  label: value,
                  value: key,
                })),
                defaultValue: 'ts',
              },
              {
                admin: {
                  components: {
                    Field: './path/to/CodeComponent#Code',
                  },
                },
                name: 'code',
                type: 'code',
              },
            ],
          }
        ],
        inlineBlocks: [],
      }),
    ],
  }),
},
```

CodeComponent.tsx:

```tsx
'use client'
import type { CodeFieldClient, CodeFieldClientProps } from 'payload'

import { CodeField, useFormFields } from '@payloadcms/ui'
import React, { useMemo } from 'react'

import { languages } from './yourFieldConfig'

const languageKeyToMonacoLanguageMap = {
  plaintext: 'plaintext',
  ts: 'typescript',
  tsx: 'typescript',
}

type Language = keyof typeof languageKeyToMonacoLanguageMap

export const Code: React.FC<CodeFieldClientProps> = ({
  autoComplete,
  field,
  forceRender,
  path,
  permissions,
  readOnly,
  renderedBlocks,
  schemaPath,
  validate,
}) => {
  const languageField = useFormFields(([fields]) => fields['language'])

  const language: Language =
    (languageField?.value as Language) ||
    (languageField?.initialValue as Language) ||
    'ts'

  const label = languages[language]

  const props: CodeFieldClient = useMemo<CodeFieldClient>(
    () => ({
      ...field,
      type: 'code',
      admin: {
        ...field.admin,
        editorOptions: undefined,
        language: languageKeyToMonacoLanguageMap[language] || language,
      },
      label,
    }),
    [field, language, label],
  )

  const key = `${field.name}-${language}-${label}`

  return (
    <CodeField
      autoComplete={autoComplete}
      field={props}
      forceRender={forceRender}
      key={key}
      path={path}
      permissions={permissions}
      readOnly={readOnly}
      renderedBlocks={renderedBlocks}
      schemaPath={schemaPath}
      validate={validate}
    />
  )
}
```

## 서버 기능

커스텀 블록으로는 충분하지 않나요? 커스텀 기능 구축을 시작하려면 진입점인 서버 기능부터 시작해야 합니다.

**예제 myFeature/feature.server.ts:**

```ts
import { createServerFeature } from '@payloadcms/richtext-lexical'

export const MyFeature = createServerFeature({
  feature: {},
  key: 'myFeature',
})
```

`createServerFeature`는 상용구 코드 없이 새 기능을 만들 수 있게 해주는 헬퍼 함수입니다.

이제 기능을 에디터에서 사용할 준비가 되었습니다:

```ts
import { MyFeature } from './myFeature/feature.server';
import { lexicalEditor } from '@payloadcms/richtext-lexical';

//...
 {
    name: 'richText',
    type: 'richText',
    editor: lexicalEditor({
      features: [
        MyFeature(),
      ],
    }),
 },
```

기본적으로 이 서버 기능은 아무것도 하지 않습니다 - 아직 기능을 추가하지 않았기 때문입니다. 기능이 무엇을 하길 원하는지에 따라 ServerFeature 타입은 lexical 에디터에 커스텀 기능을 주입할 수 있는 다양한 속성을 노출합니다.

### i18n

각 기능은 고유한 번역을 등록할 수 있으며, 이는 자동으로 기능 키로 범위가 지정됩니다:

```ts
import { createServerFeature } from '@payloadcms/richtext-lexical'

export const MyFeature = createServerFeature({
  feature: {
    i18n: {
      en: {
        label: 'My Feature',
      },
      de: {
        label: 'Mein Feature',
      },
    },
  },
  key: 'myFeature',
})
```

이를 통해 기능에 범위가 지정된 i18n 번역을 추가할 수 있습니다. 이 특정 예제 번역은 `lexical:myFeature:label` 아래에서 사용할 수 있습니다 - `myFeature`가 기능 키입니다.

### Markdown 변환기#server-feature-markdown-transformers

서버 기능은 클라이언트 기능과 마찬가지로 markdown 변환기를 추가할 수 있게 합니다. 서버의 Markdown 변환기는 [에디터를 markdown으로 또는 markdown에서 변환](/docs/rich-text/converting-markdown)할 때 사용됩니다.

```ts
import { createServerFeature } from '@payloadcms/richtext-lexical'
import type { ElementTransformer } from '@payloadcms/richtext-lexical/lexical/markdown'
import { $createMyNode, $isMyNode, MyNode } from './nodes/MyNode'

const MyMarkdownTransformer: ElementTransformer = {
  type: 'element',
  dependencies: [MyNode],
  export: (node, exportChildren) => {
    if (!$isMyNode(node)) {
      return null
    }
    return '+++'
  },
  // match ---
  regExp: /^+++\s*$/,
  replace: (parentNode) => {
    const node = $createMyNode()
    if (node) {
      parentNode.replace(node)
    }
  },
}

export const MyFeature = createServerFeature({
  feature: {
    markdownTransformers: [MyMarkdownTransformer],
  },
  key: 'myFeature',
})
```

이 예제에서 노드는 Markdown에서 `+++`로 출력되고, markdown `+++`는 에디터에서 `MyNode` 노드로 변환됩니다.

### 노드#server-feature-nodes

서버 기능에 추가된 노드는 에디터에서 노드가 렌더링되는 방식을 제어하지 않지만 노드의 다른 측면을 제어합니다:

- HTML 변환
- 노드 훅
- 하위 필드
- 헤드리스 에디터에서의 동작

`createNode` 헬퍼 함수는 적절한 타이핑으로 노드를 만드는 데 사용됩니다. 이 함수를 사용하여 노드를 만드는 것이 권장됩니다.

```ts
import { createServerFeature, createNode } from '@payloadcms/richtext-lexical'
import { MyNode } from './nodes/MyNode'

export const MyFeature = createServerFeature({
  feature: {
    nodes: [
      // createNode 헬퍼 함수를 사용하여 적절한 타이핑으로 노드를 더 쉽게 만들 수 있습니다
      createNode({
        converters: {
          html: {
            converter: () => {
              return `<hr/>`
            },
            nodeTypes: [MyNode.getType()],
          },
        },
        // 여기에 실제 노드를 추가할 수 있습니다. 서버에서는 markdown / html 변환과 같은
        // 에디터에 대한 작업을 수행하는 데 사용할 수 있는 헤드리스 에디터를 
        // 초기화하는 데 사용됩니다.
        node: MyNode,
      }),
    ],
  },
  key: 'myFeature',
})
```

클라이언트 기능의 노드는 노드 배열에 자체적으로 추가되는 반면, 서버 기능의 노드는 다음과 같은 형제 옵션과 함께 추가할 수 있습니다:

| 옵션                           | 설명                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`getSubFields`**              | 노드가 하위 필드(예: 블록 및 링크 노드)를 포함하는 경우, 여기에 subFields 스키마를 전달하면 Payload가 자동으로 채우고 훅을 실행합니다.                                                                                                                                                                                                                                                                                                                                                    |
| **`getSubFieldsData`**          | 노드가 하위 필드를 포함하는 경우, 하위 필드의 스키마를 반환하는 `getSubFields`와 함께 여기에 하위 필드 데이터를 반환해야 합니다.                                                                                                                                                                                                                                                                                                                                            |
| **`graphQLPopulationPromises`** | GraphQL에서 노드의 데이터가 요청되었을 때 채우기 로직을 실행할 수 있게 합니다. `getSubFields`와 `getSubFieldsData`는 자동으로 하위 필드 채우기를 처리하지만(하위 필드에서 훅을 실행하므로), 이것은 Rest API에서만 채워집니다. 이는 Rest API 훅이 GraphQL에서 제공하는 'depth' 속성에 액세스할 수 없기 때문입니다. GraphQL에서 올바르게 채워지려면 여기에 채우기 로직을 제공해야 합니다. |
| **`node`**                      | 실제 lexical 노드를 여기에 제공해야 합니다. 이는 [lexical 노드 교체](https://lexical.dev/docs/concepts/node-replacement)도 지원합니다.                                                                                                                                                                                                                                                                                                                                        |
| **`validations`**               | 문서가 검증될 때 다른 Payload 필드와 함께 실행되는 노드 검증을 제공할 수 있습니다. 노드의 데이터가 올바르지 않은 경우 특정 노드에 대한 검증 오류를 던지는 데 사용할 수 있습니다.                                                                                                                                                                                                                                                                                               |
| **`converters`**                | 노드를 다른 형식으로 직렬화하는 방법을 정의할 수 있습니다. 현재 HTML만 지원합니다. Markdown 변환기는 여기가 아닌 `markdownTransformers`에서 정의됩니다.                                                                                                                                                                                                                                                                                                              |
| **`hooks`**                     | Payload 필드와 마찬가지로 이 특정 노드에 대해 실행되는 훅을 제공할 수 있습니다. 이를 노드 훅이라고 합니다.                                                                                                                                                                                                                                                                                                                                                            |

### 기능 로드 순서

서버 기능은 또한 `feature` 속성으로 함수를 받을 수 있습니다(아래에서 언급된 props 정리에 유용). 이 함수는 Payload 정리 프로세스 중 기능이 로드될 때 호출됩니다:

```ts
import { createServerFeature } from '@payloadcms/richtext-lexical'

createServerFeature({
  //...
  feature: async ({
    config,
    isRoot,
    props,
    resolvedFeatures,
    unSanitizedEditorConfig,
    featureProviderMap,
  }) => {
    return {
      //실제 서버 기능이 여기에...
    }
  },
})
```

여기서 "로딩"은 이 `feature` 함수를 호출하는 프로세스를 의미합니다. 기본적으로 기능은 에디터에 추가된 순서대로 호출됩니다.
그러나 때로는 다른 기능이 로드된 후에 기능을 로드하거나, 다른 기능이 로드되도록 요구하고 그렇지 않은 경우 오류를 던지고 싶을 수 있습니다.

lexical 내에서 이것이 수행되는 한 예는 우리의 목록 기능입니다. `UnorderedListFeature`와 `OrderedListFeature` 모두 같은 `ListItem` 노드를 등록합니다. `UnorderedListFeature` 내에서는 정상적으로 등록하지만, `OrderedListFeature` 내에서는 `UnorderedListFeature`가 존재하지 않는 경우에만 `ListItem` 노드를 등록하려고 합니다 - 그렇지 않으면 같은 노드를 등록하는 두 기능이 있게 됩니다.

다음은 우리가 하는 방법입니다:

```ts
import { createServerFeature, createNode } from '@payloadcms/richtext-lexical'

export const OrderedListFeature = createServerFeature({
  feature: ({ featureProviderMap }) => {
    return {
      // ...
      nodes: featureProviderMap.has('unorderedList')
        ? []
        : [
            createNode({
              // ...
            }),
          ],
    }
  },
  key: 'orderedList',
})
```

`featureProviderMap`은 항상 사용할 수 있으며 아직 로드되지 않은 기능까지 포함하여 모든 기능을 포함하므로, 맵에 `key`가 있는지 확인하여 기능이 로드되었는지 확인할 수 있습니다.

다른 기능 전에 기능이 로드되도록 하려면 `dependenciesPriority` 속성을 사용할 수 있습니다:

```ts
import { createServerFeature } from '@payloadcms/richtext-lexical'

export const MyFeature = createServerFeature({
  feature: ({ featureProviderMap }) => {
    return {
      // ...
    }
  },
  key: 'myFeature',
  dependenciesPriority: ['otherFeature'],
})
```

| 옵션                     | 설명                                                                                                                                                                                               |
| -------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`dependenciesSoft`**     | 이 기능에 필요한 소프트 종속성의 키입니다. 이는 선택사항입니다. Payload는 이 기능 전에 로드를 시도하지만 불가능한 경우 오류를 던지지 않습니다.                          |
| **`dependencies`**         | 이 기능에 필요한 종속성의 키입니다. 이러한 종속성은 먼저 로드될 필요는 없지만 존재해야 하며, 그렇지 않으면 오류가 던져집니다.                                               |
| **`dependenciesPriority`** | 이 기능에 필요한 우선순위 종속성의 키입니다. 이러한 종속성은 먼저 로드되어야 하고 존재해야 하며, 그렇지 않으면 오류가 던져집니다. `feature` 속성에서 사용할 수 있습니다. |

## 클라이언트 기능

사용자가 실제로 보고 상호 작용하는 대부분의 기능(툴바 항목 및 노드용 React 컴포넌트 등)은 클라이언트 사이드에 있습니다.

클라이언트 사이드 기능을 설정하려면 다음 세 단계를 따르세요:

1. **별도의 파일 생성**: `myFeature/feature.client.ts`와 같이 클라이언트 기능 전용 새 파일을 만드는 것부터 시작하세요. 서버와 클라이언트 코드 간에 깔끔한 경계를 유지하기 위해 클라이언트와 서버 기능을 별도의 파일에 보관하는 것이 중요합니다.
2. **'use client'**: 파일 상단에 'use client' 지시어로 해당 파일을 표시하세요
3. **클라이언트 기능 등록**: `ClientFeature` prop에 전달하여 서버 기능 내에서 클라이언트 기능을 등록하세요. 이는 서버 기능이 기능의 유일한 진입점이기 때문에 필요합니다. 이는 또한 서버 기능 없이는 클라이언트 기능을 만들 수 없다는 것을 의미합니다. 그렇지 않으면 등록할 수 없기 때문입니다.

**예제 myFeature/feature.client.ts:**

```ts
'use client'

import { createClientFeature } from '@payloadcms/richtext-lexical/client'

export const MyClientFeature = createClientFeature({})
```

ClientFeature를 통해 사용할 수 있는 API를 탐색하여 필요한 특정 기능을 추가하세요. 클라이언트 사이드에서 작업할 때는 webpack이나 turbopack에서 오류를 일으킬 수 있으므로 `'@payloadcms/richtext-lexical'`에서 직접 가져오지 마세요. 대신 모든 클라이언트 사이드 가져오기에는 `'@payloadcms/richtext-lexical/client'`를 사용하세요. 타입 가져오기는 이 규칙에서 제외되며 항상 가져올 수 있습니다.

### 서버 기능에 클라이언트 기능 추가

서버 기능 내에서 다음과 같이 클라이언트 기능에 대한 [가져오기 경로](/docs/custom-components/overview#component-paths)를 제공할 수 있습니다:

```ts
import { createServerFeature } from '@payloadcms/richtext-lexical'

export const MyFeature = createServerFeature({
  feature: {
    ClientFeature: './path/to/feature.client#MyClientFeature',
  },
  key: 'myFeature',
  dependenciesPriority: ['otherFeature'],
})
```

### 노드#client-feature-nodes

클라이언트와 서버 기능 **모두**의 `nodes` 배열에 노드를 추가하세요. 서버 사이드에서 노드는 헤드리스 에디터에서 HTML 변환과 같은 백엔드 작업에 활용됩니다. 클라이언트 사이드에서 이러한 노드는 에디터에서 콘텐츠가 표시되고 관리되는 방식에 필수적이며, 렌더링, 동작 및 데이터베이스에 저장되는 방식에 영향을 줍니다.

예제:

**myFeature/feature.client.ts:**

```ts
'use client'

import { createClientFeature } from '@payloadcms/richtext-lexical/client'
import { MyNode } from './nodes/MyNode'

export const MyClientFeature = createClientFeature({
  nodes: [MyNode],
})
```

이는 또한 [lexical 노드 교체](https://lexical.dev/docs/concepts/node-replacement)를 지원합니다.

**myFeature/nodes/MyNode.tsx:**

다음은 기본 DecoratorNode 예제입니다:

```ts
import type {
  DOMConversionMap,
  DOMConversionOutput,
  DOMExportOutput,
  EditorConfig,
  LexicalNode,
  SerializedLexicalNode,
} from '@payloadcms/richtext-lexical/lexical'

import { $applyNodeReplacement, DecoratorNode } from '@payloadcms/richtext-lexical/lexical'

// SerializedLexicalNode는 기본 lexical 노드입니다.
// SerializedMyNode 타입을 SerializedLexicalNode로 설정하면
// 기본적으로 이 노드가 추가 데이터를 저장하지 않는다고 말하는 것입니다.
// 노드가 데이터를 저장하기를 원한다면 자유롭게 확장하세요
export type SerializedMyNode = SerializedLexicalNode

// 여기에 노드에 대한 React 컴포넌트를 지연 가져오기하세요
const MyNodeComponent = React.lazy(() =>
  import('../component/index.js').then((module) => ({
    default: module.MyNodeComponent,
  })),
)

/**
 * 이 노드는 DecoratorNode입니다. DecoratorNode를 사용하면
 * 에디터에서 React 컴포넌트를 렌더링할 수 있습니다.
 *
 * createDom과 decorate 함수가 모두 필요합니다.
 * createDom => html 외부.
 * decorate => html 내부의 React 컴포넌트.
 *
 * 대신 DecoratorBlockNode를 사용했다면
 * decorate 메서드만 필요합니다
 */
export class MyNode extends DecoratorNode<React.ReactElement> {
  static clone(node: MyNode): MyNode {
    return new MyNode(node.__key)
  }

  static getType(): string {
    return 'myNode'
  }

  /**
   * 다른 페이지에서 div 요소를 복사하여
   * lexical 에디터에 붙여넣을 때 어떤 일이 일어나는지 정의합니다
   *
   * 이는 또한 lexical의 내부 HTML -> Lexical 변환기의 동작을 결정합니다
   */
  static importDOM(): DOMConversionMap | null {
    return {
      div: () => ({
        conversion: $yourConversionMethod,
        priority: 0,
      }),
    }
  }

  /**
   * 이 노드의 데이터는 JSON으로 직렬화되어 저장됩니다.
   * 이것은 해당 노드의 "로드 함수"입니다: 저장된 데이터를 가져와서
   * 노드로 변환합니다.
   */
  static importJSON(serializedNode: SerializedMyNode): MyNode {
    return $createMyNode()
  }

  /**
   * lexical 에디터에서 hr 요소가 렌더링되는 방식을 결정합니다.
   * 이는 "초기" / "외부" HTML 요소일 뿐입니다.
   */
  createDOM(config: EditorConfig): HTMLElement {
    const element = document.createElement('div')
    return element
  }

  /**
   * createDOM이 반환하는 것 안에서
   * React 컴포넌트를 렌더링할 수 있게 합니다.
   */
  decorate(): React.ReactElement {
    return <MyNodeComponent nodeKey={this.__key} />
  }

  /**
   * importDOM의 반대로, 이 함수는 lexical 에디터에서
   * div 요소를 복사하여 다른 페이지에 붙여넣을 때
   * 어떤 일이 일어나는지 정의합니다.
   *
   * 이는 또한 lexical의 내부 Lexical -> HTML 변환기의 동작을 결정합니다
   */
  exportDOM(): DOMExportOutput {
    return { element: document.createElement('div') }
  }
  /**
   * importJSON의 반대입니다. 이것은 데이터베이스 / lexical
   * 에디터 상태에 저장되는 데이터를 결정합니다.
   */
  exportJSON(): SerializedLexicalNode {
    return {
      type: 'myNode',
      version: 1,
    }
  }

  getTextContent(): string {
    return '\n'
  }

  isInline(): false {
    return false
  }

  updateDOM(): boolean {
    return false
  }
}

// 이는 importDOM 메서드에서 사용됩니다. 특정 dom 요소를
// 에디터에 복사하여 붙여넣을 때 노드가 자동으로 생성되는 것을
// 원하지 않는다면 완전히 선택사항입니다.
function $yourConversionMethod(): DOMConversionOutput {
  return { node: $createMyNode() }
}

// 이는 새로운 MyNode를 만드는 유틸리티 메서드입니다.
// $가 접두사로 붙은 유틸리티 메서드는 이것이
// lexical 내에서만 사용되어야 한다는 것을 명시합니다
export function $createMyNode(): MyNode {
  return $applyNodeReplacement(new MyNode())
}

// 이는 노드가 MyNode인지 확인하는 데 사용할 수 있는
// 유틸리티 메서드입니다. 이는 또한 올바른 타이핑을 보장합니다.
export function $isMyNode(
  node: LexicalNode | null | undefined,
): node is MyNode {
  return node instanceof MyNode
}
```

노드는 서버에서 사용할 수 있으므로 노드에 'use client' 지시어를 추가하지 마세요.

### 플러그인

기능의 한 작은 부분은 플러그인입니다. 이름은 lexical playground 플러그인에서 유래되었으며 lexical 기능의 작은 부분일 뿐입니다.
플러그인은 모든 lexical 컨텍스트 프로바이더 내에서 에디터에 추가되는 단순히 React 컴포넌트입니다. lexical API를 활용하여
에디터에 모든 기능을 추가하는 데 사용할 수 있습니다.

가장 일반적으로는 [lexical 리스너](https://lexical.dev/docs/concepts/listeners), [노드 변환](https://lexical.dev/docs/concepts/transforms) 또는 [명령어](https://lexical.dev/docs/concepts/commands)를 등록하는 데 사용됩니다.
예를 들어, 플러그인에 drawer를 추가하고 그것을 여는 명령어를 등록할 수 있습니다. 그 명령어는 커스텀 lexical 노드 내에서처럼 lexical 내의 어디에서든 호출할 수 있습니다.

플러그인을 추가하려면 클라이언트 기능의 `plugins` 배열에 추가하면 됩니다:

```ts
'use client'

import { createClientFeature } from '@payloadcms/richtext-lexical/client'
import { MyPlugin } from './plugin'

export const MyClientFeature = createClientFeature({
  plugins: [MyPlugin],
})
```

예제 plugin.tsx:

```ts
'use client'
import type { LexicalCommand } from '@payloadcms/richtext-lexical/lexical'

import {
  createCommand,
  $getSelection,
  $isRangeSelection,
  COMMAND_PRIORITY_EDITOR,
} from '@payloadcms/richtext-lexical/lexical'

import { useLexicalComposerContext } from '@payloadcms/richtext-lexical/lexical/react/LexicalComposerContext'
import { $insertNodeToNearestRoot } from '@payloadcms/richtext-lexical/lexical/utils'
import { useEffect } from 'react'

import type { PluginComponent } from '@payloadcms/richtext-lexical' // 타입 가져오기는 클라이언트에서도 @payloadcms/richtext-lexical에서 가져올 수 있습니다

import { $createMyNode } from '../nodes/MyNode'
import './index.scss'

export const INSERT_MYNODE_COMMAND: LexicalCommand<void> = createCommand(
  'INSERT_MYNODE_COMMAND',
)

/**
 * 새로운 MyNode를 에디터에 삽입하는
 * lexical 명령어를 등록하는 플러그인
 */
export const MyNodePlugin: PluginComponent = () => {
  // useLexicalComposerContext 훅을 사용하여
  // lexical 에디터 인스턴스에 액세스할 수 있습니다
  const [editor] = useLexicalComposerContext()

  useEffect(() => {
    return editor.registerCommand(
      INSERT_MYNODE_COMMAND,
      (type) => {
        const selection = $getSelection()

        if (!$isRangeSelection(selection)) {
          return false
        }

        const focusNode = selection.focus.getNode()

        if (focusNode !== null) {
          const newMyNode = $createMyNode()
          $insertNodeToNearestRoot(newMyNode)
        }

        return true
      },
      COMMAND_PRIORITY_EDITOR,
    )
  }, [editor])

  return null
}
```

이 예제에서는 단순히 새로운 MyNode를 에디터에 삽입하는 lexical 명령어를 등록합니다. 이 명령어는 커스텀 노드 내에서처럼 lexical 내의 어디에서든 호출할 수 있습니다.

### 툴바 그룹

툴바 그룹은 툴바 항목을 보유하는 시각적 컨테이너입니다. 툴바 항목이 _어떻게_ 표시되는지 결정하는 다른 툴바 그룹 유형이 있습니다: `dropdown`과 `buttons`.

모든 기본 툴바 그룹은 `@payloadcms/richtext-lexical/client`에서 내보냅니다. 이를 사용하여 에디터에 고유한 툴바 항목을 추가할 수 있습니다:

- Dropdown: `toolbarAddDropdownGroupWithItems`
- Dropdown: `toolbarTextDropdownGroupWithItems`
- Buttons: `toolbarFormatGroupWithItems`
- Buttons: `toolbarFeatureButtonsGroupWithItems`

드롭다운 그룹 내에서 항목은 드롭다운이 열릴 때 수직으로 배치되며 아이콘과 레이블을 포함합니다. 버튼 그룹 내에서 항목은 수평으로 배치되며 아이콘만 포함합니다. 같은 키를 가진 툴바 그룹이 두 번 선언되면 모든 항목이 하나의 그룹으로 병합됩니다.

#### 커스텀 버튼 툴바 그룹

| 옵션      | 설명                                                                                                                                            |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **`items`** | 이 툴바 그룹에 속하는 모든 툴바 항목을 여기에 추가해야 합니다.                                                                                    |
| **`key`**   | 각 툴바 그룹에는 고유한 키가 있어야 합니다. 같은 키를 가진 그룹은 항목이 함께 병합됩니다.                                        |
| **`order`** | 툴바 그룹이 위치할 곳을 결정합니다.                                                                                                            |
| **`type`**  | 툴바 그룹 유형을 제어합니다. 아이콘만 사용하여 툴바 항목을 수평으로 표시하는 버튼 툴바 그룹을 만들려면 `buttons`로 설정하세요. |

예제:

```ts
import type {
  ToolbarGroup,
  ToolbarGroupItem,
} from '@payloadcms/richtext-lexical'

export const toolbarFormatGroupWithItems = (
  items: ToolbarGroupItem[],
): ToolbarGroup => {
  return {
    type: 'buttons',
    items,
    key: 'myButtonsToolbar',
    order: 10,
  }
}
```

#### 커스텀 드롭다운 툴바 그룹

| 옵션               | 설명                                                                                                                                                                          |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **`items`**          | 이 툴바 그룹에 속하는 모든 툴바 항목을 여기에 추가해야 합니다.                                                                                                                  |
| **`key`**            | 각 툴바 그룹에는 고유한 키가 있어야 합니다. 같은 키를 가진 그룹은 항목이 함께 병합됩니다.                                                                      |
| **`order`**          | 툴바 그룹이 위치할 곳을 결정합니다.                                                                                                                                          |
| **`type`**           | 툴바 그룹 유형을 제어합니다. 드롭다운이 열렸을 때 아이콘과 레이블을 사용하여 툴바 항목을 수직으로 표시하는 버튼 툴바 그룹을 만들려면 `dropdown`으로 설정하세요. |
| **`ChildComponent`** | 드롭다운 툴바 ChildComponent를 사용하면 드롭다운 버튼 내에 표시될 React 컴포넌트를 전달할 수 있습니다.                                                      |

예제:

```ts
import type {
  ToolbarGroup,
  ToolbarGroupItem,
} from '@payloadcms/richtext-lexical'

import { MyIcon } from './icons/MyIcon'

export const toolbarAddDropdownGroupWithItems = (
  items: ToolbarGroupItem[],
): ToolbarGroup => {
  return {
    type: 'dropdown',
    ChildComponent: MyIcon,
    items,
    key: 'myDropdownToolbar',
    order: 10,
  }
}
```

### 툴바 항목

커스텀 노드와 기능은 그 자체로는 에디터에 추가할 수 없다면 무의미합니다. 사용자가 에디터와 상호 작용할 수 있게 해주는 인터페이스 중 하나에 연결해야 합니다:

- 에디터 상단에 고정되어 있는 고정 툴바
- 텍스트를 선택할 때 나타나는 인라인, 플로팅 툴바
- 에디터에서 `/`를 입력할 때 나타나는 슬래시 메뉴
- 에디터에서 특정 텍스트 패턴을 입력할 때 트리거되는 Markdown 변환기
- 또는 고유한 플러그인을 통해 추가할 수 있는 다른 인터페이스. 우리의 툴바는 이것의 대표적인 예입니다 - 그것들은 단지 플러그인입니다.

플로팅 또는 인라인 툴바에 툴바 항목을 추가하려면 클라이언트 기능의 `toolbarFixed` 또는 `toolbarInline` props에 ToolbarItem이 있는 ToolbarGroup을 추가할 수 있습니다:

```ts
'use client'

import {
  createClientFeature,
  toolbarAddDropdownGroupWithItems,
} from '@payloadcms/richtext-lexical/client'
import { IconComponent } from './icon'
import { $isHorizontalRuleNode } from './nodes/MyNode'
import { INSERT_MYNODE_COMMAND } from './plugin'
import { $isNodeSelection } from '@payloadcms/richtext-lexical/lexical'

export const MyClientFeature = createClientFeature({
  toolbarFixed: {
    groups: [
      toolbarAddDropdownGroupWithItems([
        {
          ChildComponent: IconComponent,
          isActive: ({ selection }) => {
            if (!$isNodeSelection(selection) || !selection.getNodes().length) {
              return false
            }

            const firstNode = selection.getNodes()[0]
            return $isHorizontalRuleNode(firstNode)
          },
          key: 'myNode',
          label: ({ i18n }) => {
            return i18n.t('lexical:myFeature:label')
          },
          onSelect: ({ editor }) => {
            editor.dispatchCommand(INSERT_MYNODE_COMMAND, undefined)
          },
        },
      ]),
    ],
  },
})
```

먼저 툴바 그룹을 제공한 다음 해당 툴바 그룹의 항목을 제공해야 합니다(위에 자세히 설명됨).

`ToolbarItem`은 동작을 커스터마이즈하는 데 사용할 수 있는 다양한 props를 제공합니다:

| 옵션               | 설명                                                                                                                                                                                |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **`ChildComponent`** | 툴바 항목의 기본 버튼 컴포넌트 내에서 렌더링되는 React 컴포넌트입니다. 보통 이것은 아이콘이어야 합니다.                                                             |
| **`Component`**      | 툴바 항목의 기본 버튼 컴포넌트 대신 렌더링되는 React 컴포넌트로, 완전히 대체합니다. `ChildComponent`와 `onSelect` 속성은 무시됩니다. |
| **`label`**          | 드롭다운 그룹 내에 있는 경우 툴바 항목에 레이블이 표시됩니다. i18n을 활용하려면 이것은 함수일 수 있습니다.                                                            |
| **`key`**            | 각 툴바 항목에는 고유한 키가 있어야 합니다.                                                                                                                                              |
| **`onSelect`**       | 툴바 항목을 클릭할 때 호출되는 함수입니다.                                                                                                                               |
| **`isEnabled`**      | 이는 선택사항이며 툴바 항목이 클릭 가능한지 여부를 제어합니다. 여기서 `false`가 반환되면 회색으로 표시되고 클릭할 수 없습니다.                                                 |
| **`isActive`**       | 이는 선택사항이며 툴바 항목이 강조 표시되는지 여부를 제어합니다                                                                                                                    |

플로팅 인라인 툴바(`toolbarInline`)에 항목을 추가하는 API는 동일합니다. 고정 툴바와 인라인 툴바 모두에 항목을 추가하려면 별도의 변수로 추출하고
(`ToolbarGroup[]`로 타입 지정) `toolbarFixed`와 `toolbarInline` props 모두에 추가할 수 있습니다.

### 슬래시 메뉴 그룹

"Basic"이라고 표시된 슬래시 메뉴에 항목을 추가하는 데 사용할 수 있는 `slashMenuBasicGroupWithItems`를 `@payloadcms/richtext-lexical/client`에서 내보냅니다. 고유한 슬래시 메뉴 그룹을 만들고 싶다면 다음 예제를 참조하세요:

```ts
import type {
  SlashMenuGroup,
  SlashMenuItem,
} from '@payloadcms/richtext-lexical'

export function mwnSlashMenuGroupWithItems(
  items: SlashMenuItem[],
): SlashMenuGroup {
  return {
    items,
    key: 'myGroup',
    label: 'My Group', // <= 이는 i18n을 활용하기 위한 함수일 수 있습니다
  }
}
```

이와 같은 헬퍼 함수를 만들면 쉽게 재사용하고 항목을 추가할 수 있습니다. 같은 키를 가진 모든 슬래시 메뉴 그룹은 항목이 함께 병합됩니다.

| 옵션      | 설명                                                                                                                           |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| **`items`** | 슬래시 메뉴에 표시될 `SlashMenuItem` 배열입니다.                                                              |
| **`label`** | 슬래시 메뉴 그룹 앞에 표시될 레이블입니다. i18n을 활용하려면 이것은 함수일 수 있습니다.                       |
| **`key`**   | 클래스 이름에 사용되며, 레이블이 제공되지 않은 경우 표시에 사용됩니다. 같은 키를 가진 슬래시 메뉴는 항목이 함께 병합됩니다. |

### 슬래시 메뉴 항목

슬래시 메뉴에 항목을 추가하는 API도 유사합니다. 슬래시 메뉴 그룹이 있고 각 슬래시 메뉴 그룹에는 항목이 있습니다. 다음은 예제입니다:

```ts
'use client'

import {
  createClientFeature,
  slashMenuBasicGroupWithItems,
} from '@payloadcms/richtext-lexical/client'
import { INSERT_MYNODE_COMMAND } from './plugin'
import { IconComponent } from './icon'

export const MyClientFeature = createClientFeature({
  slashMenu: {
    groups: [
      slashMenuBasicGroupWithItems([
        {
          Icon: IconComponent,
          key: 'myNode',
          keywords: ['myNode', 'myFeature', 'someOtherKeyword'],
          label: ({ i18n }) => {
            return i18n.t('lexical:myFeature:label')
          },
          onSelect: ({ editor }) => {
            editor.dispatchCommand(INSERT_MYNODE_COMMAND, undefined)
          },
        },
      ]),
    ],
  },
})
```

| 옵션         | 설명                                                                                                                                                                                                                                                                       |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`Icon`**     | 슬래시 메뉴 항목에서 렌더링되는 아이콘입니다.                                                                                                                                                                                                                               |
| **`label`**    | 슬래시 메뉴 항목에 표시될 레이블입니다. i18n을 활용하려면 이것은 함수일 수 있습니다.                                                                                                                                                                        |
| **`key`**      | 각 슬래시 메뉴 항목에는 고유한 키가 있어야 합니다. 키는 입력할 때 매치되고, `label` 속성이 설정되지 않은 경우 표시되며, className에 사용됩니다.                                                                           |
| **`onSelect`** | 슬래시 메뉴 항목이 선택될 때 호출되는 함수입니다.                                                                                                                                                                                                                                  |
| **`keywords`** | 키워드는 '/' 다음에 입력된 다른 텍스트에 대해 항목을 매치하는 데 사용됩니다. 예를 들어, /hr, /separator, /horizontal 등을 입력할 때 수평 규칙 항목을 표시하고 싶을 수 있습니다. 키워드 외에도 레이블과 키가 올바른 슬래시 메뉴 항목을 찾는 데 사용됩니다. |

### Markdown 변환기#client-feature-markdown-transformers

클라이언트 기능은 서버 기능과 마찬가지로 markdown 변환기를 추가할 수 있게 합니다. 클라이언트의 Markdown 변환기는 에디터에서 특정 markdown 패턴을 입력할 때 새 노드를 만드는 데 사용됩니다.

```ts
import { createClientFeature } from '@payloadcms/richtext-lexical/client'
import type { ElementTransformer } from '@payloadcms/richtext-lexical/lexical/markdown'
import { $createMyNode, $isMyNode, MyNode } from './nodes/MyNode'

const MyMarkdownTransformer: ElementTransformer = {
  type: 'element',
  dependencies: [MyNode],
  export: (node, exportChildren) => {
    if (!$isMyNode(node)) {
      return null
    }
    return '+++'
  },
  // match ---
  regExp: /^+++\s*$/,
  replace: (parentNode) => {
    const node = $createMyNode()
    if (node) {
      parentNode.replace(node)
    }
  },
}

export const MyFeature = createClientFeature({
  markdownTransformers: [MyMarkdownTransformer],
})
```

이 예제에서는 `+++ `를 입력할 때 새로운 `MyNode`가 에디터에 삽입됩니다.

### 프로바이더

클라이언트 기능에 프로바이더를 추가할 수 있으며, 이는 `EditorConfigProvider` 아래에 중첩됩니다. 노드나 기능의 다른 부분에 컨텍스트를 제공하고 싶을 때 유용할 수 있습니다.

```ts
'use client'

import { createClientFeature } from '@payloadcms/richtext-lexical/client'
import { TableContext } from './context'

export const MyClientFeature = createClientFeature({
  providers: [TableContext],
})
```

## Props

기능에서 props를 받으려면 제네릭으로 타입을 지정하세요.

서버 기능:

```ts
createServerFeature<UnSanitizedProps, SanitizedProps, UnSanitizedClientProps>({
  //...
})
```

클라이언트 기능:

```ts
createClientFeature<UnSanitizedClientProps, SanitizedClientProps>({
  //...
})
```

정리되지 않은 props는 사용자가 기능의 프로바이더 함수를 호출하여 에디터 설정에 추가할 때 기능에 전달하는 것입니다. 그런 다음 해당 props를 정리할 수 있는 옵션이 있습니다.
서버 기능에서 정리하려면 객체 대신 함수를 `feature`에 전달할 수 있습니다:

```ts
createServerFeature<UnSanitizedProps, SanitizedProps, UnSanitizedClientProps>({
  //...
  feature: async ({
    config,
    isRoot,
    props,
    resolvedFeatures,
    unSanitizedEditorConfig,
    featureProviderMap,
  }) => {
    const sanitizedProps = doSomethingWithProps(props)

    return {
      sanitizedServerFeatureProps: sanitizedProps,
      //실제 서버 기능이 여기에...
    }
  },
})
```

정리된 props는 `sanitizedServerFeatureProps` 속성에서 반환되어야 한다는 점을 명심하세요.

클라이언트 기능에서는 유사하게 작동합니다:

```ts
createClientFeature<UnSanitizedClientProps, SanitizedClientProps>(
  ({
    clientFunctions,
    featureProviderMap,
    props,
    resolvedFeatures,
    unSanitizedEditorConfig,
  }) => {
    const sanitizedProps = doSomethingWithProps(props)
    return {
      sanitizedClientFeatureProps: sanitizedProps,
      //실제 클라이언트 기능이 여기에...
    }
  },
)
```

### 서버에서 클라이언트로 props 가져오기

기본적으로 클라이언트 기능은 서버 기능에서 어떤 props도 받지 않습니다. 서버에서 클라이언트로 props를 전달하려면 서버 기능에서 해당 props를 반환해야 합니다:

```ts
type UnSanitizedClientProps = {
  test: string
}

createServerFeature<UnSanitizedProps, SanitizedProps, UnSanitizedClientProps>({
  //...
  feature: {
    clientFeatureProps: {
      test: 'myValue',
    },
  },
})
```

클라이언트 기능이 기본적으로 서버와 동일한 props를 사용할 수 없는 이유는 모든 클라이언트 props가 직렬화 가능해야 하기 때문입니다. 서버 기능에서 함수나 Map과 같은 것들을 props로 완전히 받을 수 있지만 클라이언트에 보낼 수는 없습니다. 결국 이러한 props는 네트워크를 통해 서버에서 클라이언트로 전송되므로 직렬화 가능해야 합니다.

## 더 많은 정보

[우리가 이미 구축한 기능들](https://github.com/payloadcms/payload/tree/main/packages/richtext-lexical/src/features)을 살펴보세요 - 그것들이 어떻게 작동하는지 이해하면 고유한 기능을 만드는 방법을 이해하는 데 도움이 될 것입니다. 기본적으로 포함된 기능과 직접 만드는 기능 사이에는 차이가 없습니다 - 이러한 기능들은 모두 "코어"에서 분리되어 있으므로, 기능이 Payload의 일부인지 여부에 관계없이 동일한 API에 액세스할 수 있습니다!