---
title: Slate 에디터
label: Slate (레거시)
order: 100
desc: Slate 에디터는 베타 이후부터 Payload에서 지원되었습니다. 매우 강력하며 콘텐츠를 JSON으로 저장하여 많은 기능을 제공합니다.
keywords: slatejs, slate, rich text, editor, headless cms
---

<Banner type="warning">

[기본 Payload 에디터](/docs/rich-text/overview)는 현재 Lexical 기반입니다. 이 문서는
이전 Slate 기반 에디터에 관한 것입니다. 여전히 지원되므로 계속 사용할 수 있거나,
Slate에서 Lexical로 마이그레이션하는 선택적 [마이그레이션 가이드](/docs/rich-text/migration)를 참조할 수 있습니다(권장).

</Banner>

Slate 에디터를 사용하려면 먼저 설치해야 합니다:

```
npm install --save @payloadcms/richtext-slate
```

설치 후, 최상위 Payload 설정에 전달할 수 있습니다:

```ts
import { buildConfig } from 'payload'
import { slateEditor } from '@payloadcms/richtext-slate'

export default buildConfig({
  collections: [
    // 여기에 컬렉션들
  ],
  // Slate 에디터를 루트 설정에 전달
  editor: slateEditor({}),
})
```

다음은 옵션을 커스터마이징하면서 필드별로 Slate 에디터를 설치하는 방법의 예제입니다:

```ts
import type { CollectionConfig } from 'payload'
import { slateEditor } from '@payloadcms/richtext-slate'

export const Pages: CollectionConfig = {
  slug: 'pages',
  fields: [
    {
      name: 'content',
      type: 'richText',
      // 여기에 Slate 에디터를 전달하고 그에 따라 설정
      editor: slateEditor({
        admin: {
          elements: [
            // Slate 에디터에서 허용되는 요소를 여기에 커스터마이즈
          ],
          leaves: [
            // Slate 에디터에서 허용되는 리프를 여기에 커스터마이즈
          ],
        },
      }),
    },
  ],
}
```

## 관리자 옵션

**`elements`**

`elements` 속성은 관리자 패널 내에서 필드에 사용할 수 있도록 할 내장 또는 커스텀 [SlateJS 요소](https://docs.slatejs.org/concepts/02-nodes#element)를 지정하는 데 사용됩니다.

Payload에서 사용할 수 있는 기본 `elements`는 다음과 같습니다:

- `h1`
- `h2`
- `h3`
- `h4`
- `h5`
- `h6`
- `blockquote`
- `link`
- `ol`
- `ul`
- `li`
- `textAlign`
- `indent`
- [`relationship`](#relationship-element)
- [`upload`](#upload-element)
- [`textAlign`](#text-align)

**`leaves`**

`leaves` 속성은 관리자 패널 내에서 활성화할 내장 또는 커스텀 [SlateJS 리프](https://docs.slatejs.org/concepts/08-rendering#leaves)를 지정합니다.

Payload에서 사용할 수 있는 기본 `leaves`는 다음과 같습니다:

- `bold`
- `code`
- `italic`
- `strikethrough`
- `underline`

**`link.fields`**

이를 통해 Rich Text Editor 내의 링크에 추가 필드로 [필드](/docs/fields/overview)를 저장할 수 있습니다. 이것이 있으면 링크 요소의 "편집" 버튼을 클릭하여 열 수 있는 모달 안에 필드들이 렌더링됩니다.

`link.fields`는 필드 배열이거나(이 경우 정의된 모든 필드가 기본 필드 아래에 추가됨) 기본 필드를 유일한 인수로 받아서 사용할 전체 필드를 정의하는 배열을 반환하는 함수일 수 있습니다(따라서 기본 필드를 재정의하는 메커니즘 제공).

![RichText 링크 필드](https://payloadcms.com/images/docs/fields/richText/rte-link-fields-modal.jpg)
_커스텀 필드가 있는 RichText 링크_

**`upload.collections[collection-name].fields`**

이를 통해 Rich Text Editor 내의 업로드 필드에 메타 데이터로 [필드](/docs/fields/overview)를 저장할 수 있습니다. 이것이 있으면 업로드 요소의 "편집" 버튼을 클릭하여 열 수 있는 모달 안에 필드들이 렌더링됩니다.

![RichText 업로드 요소](https://payloadcms.com/images/docs/fields/richText/rte-upload-element.jpg)
_업로드 요소를 사용하는 RichText 필드_

![RichText 업로드 요소 모달](https://payloadcms.com/images/docs/fields/richText/rte-upload-fields-modal.jpg)
_설정에서 필드를 표시하는 RichText 업로드 요소 모달_

### Relationship 요소

내장된 `relationship` 요소는 Rich Text 에디터 내에서 다른 문서를 직접 참조하는 강력한 방법입니다.

### Upload 요소

`relationship` 요소와 유사하게, `upload` 요소는 미디어/이미지 기반 업로드를 위해 특별히 설계된 UI로 [업로드 활성화 컬렉션](/docs/upload/overview)을 참조하는 사용자 친화적인 방법입니다.

<Banner type="success">
  **팁:**

컬렉션은 기본적으로 Rich Text relationship 및 upload 요소 내에서 자동으로 선택될 수 있습니다. 
컬렉션이 Rich Text 필드에서 참조되는 것을 비활성화하려면 **enableRichTextLink** 및
**enableRichTextRelationship** 컬렉션 관리자 옵션을 false로 설정하세요.

</Banner>

Relationship 및 Upload 요소는 Rich Text 필드의 콘텐츠에 동적으로 채워집니다. REST 및 Local API 내에서, 존재하는 모든 RichText `relationship` 또는 `upload` 요소는 전달하는 `depth` 옵션을 존중하고 그에 따라 채워집니다. GraphQL에서 각 `richText` 필드는 활용할 수 있는 `depth` 인수를 받습니다.

### TextAlign 요소

텍스트 정렬은 기본적으로 포함되지 않으며 요소 목록에 `textAlign`을 추가하여 Rich Text Editor에 추가할 수 있습니다. TextAlign은 결과 JSON에 새로운 `textAlign` 필드를 포함하도록 기존 요소를 변경합니다. 이 필드는 다른 요소 및 리프와 함께 사용하여 콘텐츠를 왼쪽, 중앙 또는 오른쪽으로 배치할 수 있습니다.

### 허용할 요소와 리프 지정

이 필드에 허용되어야 할 기본 요소나 리프를 지정하려면 활성화하려는 각 요소나 리프의 문자열 이름을 포함하는 배열을 정의하세요. 커스텀 요소나 리프를 지정하려면 아래에 설명된 모든 해당 속성을 가진 객체를 전달하세요. 이 모든 것이 어떻게 작동하는지 참조하려면 [예제](#example)를 확인하세요.

### 커스텀 요소와 리프 구축

에디터를 고유한 기능으로 확장하기 위해 고유한 Slate 요소와 리프를 디자인하고 구축할 수 있습니다. 이를 위해 먼저 [SlateJS 문서](https://docs.slatejs.org/)를 읽고 [Slate 예제](https://www.slatejs.org/examples/richtext)를 보며 SlateJS 에디터를 전체적으로 숙지하는 것부터 시작하세요.

관련된 일반적인 개념을 파악한 후, 필드의 관리자 설정에 고유한 요소와 리프를 전달할 수 있습니다.

**커스텀 요소와 리프는 모두 다음 설정을 통해 정의됩니다:**

| 속성        | 설명                                                |
| --------------- | ---------------------------------------------------------- |
| **`name`** \*   | 이 요소의 `type`으로 사용될 기본 이름입니다.  |
| **`Button`** \* | Rich Text 툴바에 렌더링될 React 컴포넌트입니다. |
| **`plugins`**   | Rich Text 에디터에 제공할 플러그인 배열입니다.    |
| **`type`**      | `name`에서 사용하는 기본 타입을 재정의하는 타입      |

커스텀 `Element`는 또한 rich text 에디터 자체 내에서 `Element`로 렌더링될 React 컴포넌트로 설정된 `Element` 속성이 필요합니다.

커스텀 `Leaf` 객체는 유사한 패턴을 따르지만 대신 `Leaf` 속성을 정의해야 합니다.

커스텀 `Type`을 지정하면 JSON 객체에 추가 필드를 추가하여 커스텀 요소를 확장할 수 있습니다.

### 예제

`collections/ExampleCollection.ts`

```ts
import type { CollectionConfig } from 'payload'

import { slateEditor } from '@payloadcms/richtext-slate'

export const ExampleCollection: CollectionConfig = {
  slug: 'example-collection',
  fields: [
    {
      name: 'content', // 필수
      type: 'richText', // 필수
      defaultValue: [
        {
          children: [{ text: 'Here is some default content for this field' }],
        },
      ],
      required: true,
      editor: slateEditor({
        admin: {
          elements: [
            'h2',
            'h3',
            'h4',
            'link',
            'blockquote',
            {
              name: 'cta',
              Button: CustomCallToActionButton,
              Element: CustomCallToActionElement,
              plugins: [
                // 이 요소에 필요한 플러그인들을 여기에
              ],
            },
          ],
          leaves: [
            'bold',
            'italic',
            {
              name: 'highlight',
              Button: CustomHighlightButton,
              Leaf: CustomHighlightLeaf,
              plugins: [
                // 이 리프에 필요한 플러그인들을 여기에
              ],
            },
          ],
          link: {
            // Link 요소에 고유한 필드를 주입
            fields: [
              {
                name: 'rel',
                label: 'Rel Attribute',
                type: 'select',
                hasMany: true,
                options: ['noopener', 'noreferrer', 'nofollow'],
              },
            ],
          },
          upload: {
            collections: {
              media: {
                fields: [
                  // `media` 컬렉션의 업로드 요소에
                  // 저장하고 싶은 필드들
                ],
              },
            },
          },
        },
      }),
    },
  ],
}
```

### HTML 생성

Rich Text 필드는 콘텐츠를 JSON 형식으로 저장하므로 직접 HTML로 렌더링해야 합니다. 다음은 Rich Text 콘텐츠에서 JSX/HTML을 생성하는 방법의 예제입니다:

```ts
import React, { Fragment } from "react";
import escapeHTML from "escape-html";
import { Text } from "slate";

const serialize = (children) =>
  children.map((node, i) => {
    if (Text.isText(node)) {
      let text = (
        <span dangerouslySetInnerHTML={{ __html: escapeHTML(node.text) }} />
      );

      if (node.bold) {
        text = <strong key={i}>{text}</strong>;
      }

      if (node.code) {
        text = <code key={i}>{text}</code>;
      }

      if (node.italic) {
        text = <em key={i}>{text}</em>;
      }

      // 다른 리프 타입들을 여기에서 처리...

      return <Fragment key={i}>{text}</Fragment>;
    }

    if (!node) {
      return null;
    }

    switch (node.type) {
      case "h1":
        return <h1 key={i}>{serialize(node.children)}</h1>;
      // 모든 제목들을 여기에서 반복...
      case "h6":
        return <h6 key={i}>{serialize(node.children)}</h6>;
      case "blockquote":
        return <blockquote key={i}>{serialize(node.children)}</blockquote>;
      case "ul":
        return <ul key={i}>{serialize(node.children)}</ul>;
      case "ol":
        return <ol key={i}>{serialize(node.children)}</ol>;
      case "li":
        return <li key={i}>{serialize(node.children)}</li>;
      case "link":
        return (
          <a href={escapeHTML(node.url)} key={i}>
            {serialize(node.children)}
          </a>
        );

      default:
        return <p key={i}>{serialize(node.children)}</p>;
    }
  });
```

<Banner>
  **참고:**

위 예제는 JSX로 렌더링하는 방법이지만 일반 HTML의 패턴도 유사합니다.
JSX를 제거하고 대신 HTML 문자열을 반환하면 됩니다!

</Banner>

### 내장 SlateJS 플러그인

Payload는 고유한 요소와 리프를 개발하는 것을 좀 더 쉽게 만들기 위해 확장할 수 있는 몇 가지 내장 SlateJS 플러그인과 함께 제공됩니다.

#### `shouldBreakOutOnEnter`

Payload의 내장 제목 요소들은 모두 현재 활성 요소에서 "벗어나기" 위한 "하드 리턴"을 허용합니다. 예를 들어, `h1`을 입력하는 동안 `enter`를 누르면 `h1`에서 "벗어나" 기본 단락 요소로 계속 쓸 수 있게 됩니다.

고유한 커스텀 요소 내에서 이 기능을 활용하려면 다음 "large body" 요소 예제처럼 `element`에 커스텀 플러그인을 추가하여 수행할 수 있습니다:

`customLargeBodyElement.js`:

```ts
import Button from './Button'
import Element from './Element'
import withLargeBody from './plugin'

export default {
  name: 'large-body',
  Button,
  Element,
  plugins: [
    (incomingEditor) => {
      const editor = incomingEditor
      const { shouldBreakOutOnEnter } = editor

      editor.shouldBreakOutOnEnter = (element) =>
        element.type === 'large-body' ? true : shouldBreakOutOnEnter(element)

      return editor
    },
  ],
}
```

위에서 `large-body`라는 이름의 커스텀 SlateJS 요소를 만들고 있음을 볼 수 있습니다. 이는 앱의 프론트엔드에서 약간 더 큰 본문 카피를 렌더링할 수 있습니다. name, button, element를 전달하지만 추가로 단일 SlateJS 플러그인을 포함하는 `plugins` 배열을 전달합니다.

플러그인 자체는 `enter` 키를 눌렀을 때 "벗어나야" 하는 요소 목록에 자체 요소 이름을 추가하기 위해 Payload의 내장 `shouldBreakOutOnEnter` Slate 함수를 확장합니다.

### TypeScript

고유한 커스텀 Rich Text 요소나 리프를 구축하는 경우 다음 타입을 가져오는 것이 도움이 될 수 있습니다:

```ts
import type {
  RichTextCustomElement,
  RichTextCustomLeaf,
} from '@payloadcms/richtext-slate'
```