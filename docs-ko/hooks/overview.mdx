---
title: 훅 개요
label: 개요
order: 10
desc: 훅을 사용하면 타사 API와의 통합, 자동 생성 데이터 추가, Payload의 기본 기능 수정 등을 포함하여 Payload에 자체 로직을 추가할 수 있습니다.
keywords: 훅, 개요, 구성, 설정, 문서, 콘텐츠 관리 시스템, cms, 헤드리스, javascript, node, react, nextjs
---

훅을 사용하면 문서 라이프사이클의 특정 이벤트 중에 자체 부작용을 실행할 수 있습니다. 데이터 변형, 비즈니스 로직 수행, 타사와의 통합 또는 기타 모든 작업을 애플리케이션 내의 정확한 순간에 수행할 수 있습니다.

훅을 사용하면 Payload를 전통적인 CMS에서 완전한 애플리케이션 프레임워크로 변환할 수 있습니다. 훅의 많은 사용 사례가 있습니다:

- 읽거나 업데이트되기 전에 데이터 수정
- 민감한 데이터 암호화 및 복호화  
- HubSpot이나 Salesforce와 같은 타사 CRM과 통합
- 업로드된 파일의 사본을 Amazon S3 등으로 전송
- Stripe와 같은 결제 제공업체를 통한 주문 처리
- 연락처 양식이 제출될 때 이메일 발송
- 시간에 따른 데이터 소유권이나 변경사항 추적

Payload에는 네 가지 주요 유형의 훅이 있습니다:

- [루트 훅](#root-hooks)
- [컬렉션 훅](/docs/hooks/collections)
- [글로벌 훅](/docs/hooks/globals)
- [필드 훅](/docs/hooks/fields)

<Banner type="warning">
  **알림:** Payload는 프론트엔드 애플리케이션에서 사용할 수 있는 _React_ 훅
  세트도 제공합니다. 공통된 이름을 공유하지만 이들은 매우 다른 것들이며
  혼동해서는 안 됩니다. [자세한 내용](../admin/react-hooks).
</Banner>

## 루트 훅

루트 훅은 특정 컬렉션, 글로벌 또는 필드와 연관되지 않습니다. 애플리케이션 레벨에서 오류가 발생할 때와 같은 전역 지향적인 부작용에 유용합니다.

루트 훅을 추가하려면 [Payload Config](/docs/configuration/overview)에서 `hooks` 속성을 사용하세요:

```ts
import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  // highlight-start
  hooks: {
    afterError:[() => {...}]
  },
  // highlight-end
})
```

다음 옵션들을 사용할 수 있습니다:

| 옵션             | 설명                                        |
| ---------------- | ------------------------------------------- |
| **`afterError`** | Payload 애플리케이션에서 오류가 발생한 후 실행됩니다. |

### afterError

`afterError` 훅은 Payload 애플리케이션에서 오류가 발생할 때 트리거됩니다. 이는 타사 서비스로 오류를 로깅하거나 개발팀에 이메일을 보내거나 Sentry나 DataDog에 오류를 로깅하는 등에 유용할 수 있습니다. 출력은 결과 객체/상태 코드를 변환하는 데 사용할 수 있습니다.

```ts
import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  hooks: {
    afterError: [
      async ({ error }) => {
        // 무언가 수행
      },
    ],
  },
})
```

다음 인수들이 `afterError` 훅에 제공됩니다:

| 인수                | 설명                                                                                                                                                                             |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`error`**         | 발생한 오류.                                                                                                                                                                     |
| **`context`**       | 훅 간에 전달되는 커스텀 컨텍스트. [자세한 내용](./context).                                                                                                                      |
| **`graphqlResult`** | GraphQL 결과 객체, GraphQL 컨텍스트 내에서 훅이 실행되는 경우 사용 가능.                                                                                                         |
| **`req`**           | [Web Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)를 확장하는 `PayloadRequest` 객체. 현재 인증된 `user`와 Local API 인스턴스 `payload`를 포함합니다. |
| **`collection`**    | 이 훅이 실행되는 [컬렉션](../configuration/collections). 비컬렉션 엔드포인트나 GraphQL에서 훅이 실행되는 경우 `undefined`입니다.                                             |
| **`result`**        | 포맷된 오류 결과 객체, REST 컨텍스트에서 훅이 실행되는 경우 사용 가능.                                                                                                           |

## 비동기 vs. 동기

모든 훅은 동기 또는 비동기 함수로 작성할 수 있습니다. 올바른 유형 선택은 사용 사례에 따라 달라지지만, 두 유형 간의 전환은 `async` 키워드를 추가하거나 제거하는 것만큼 간단합니다.

#### 비동기

훅이 문서가 업데이트되거나 생성되기 전에 데이터를 수정해야 하고 타사에서 데이터를 가져오는 것과 같은 비동기 작업에 의존하는 경우, 훅을 비동기 함수로 정의하는 것이 합리적일 수 있습니다. 이렇게 하면 작업의 라이프사이클이 계속되기 전에 훅이 완료되는 것을 확신할 수 있습니다.

비동기 훅은 직렬로 실행됩니다 - 따라서 두 개의 비동기 훅이 정의되어 있으면 두 번째 훅은 첫 번째 훅이 완료될 때까지 기다린 후 시작됩니다.

<Banner type="success">
  **팁:** 훅이 응답에 어떤 식으로든 영향을 주지 않는 장시간 실행 작업을 수행하는
  경우, [작업 큐로 오프로딩](#offloading-long-running-tasks)하는 것을 고려하세요.
  이렇게 하면 작업이 완료될 때까지 기다리지 않고 요청이 계속 처리될 수 있습니다.
</Banner>

#### 동기

훅이 문서 데이터를 변형하는 것과 같은 부작용만 수행하는 경우, 동기적으로 정의하여 Payload 작업이 훅이 완료될 때까지 기다릴 필요가 없도록 하는 것이 괜찮을 수 있습니다.

## 서버 전용 실행

훅은 서버에서만 트리거되며 클라이언트 측 번들에서 자동으로 제외됩니다. 즉, 클라이언트에 노출될 걱정 없이 훅에서 민감한 비즈니스 로직을 안전하게 사용할 수 있습니다.

## 성능

훅은 API의 동작을 커스터마이징하는 강력한 방법이지만, 일부 훅은 매우 자주 실행되며 최적화되지 않으면 요청에 상당한 오버헤드를 추가할 수 있습니다.

훅을 구축할 때는 훅이 가능한 한 성능이 좋도록 하기 위해 이러한 전략들을 가능한 한 많이 결합하세요.

<Banner type="success">
  더 많은 성능 팁은 [성능 문서](../performance/overview)를 참조하세요.
</Banner>

### 효율적인 훅 작성

훅이 언제 실행되는지 고려하세요. 일반적인 함정 중 하나는 매우 자주 실행되는 훅에 비용이 많이 드는 로직을 넣는 것입니다.

예를 들어, `read` 작업은 모든 읽기 요청에서 실행되므로 `beforeRead`나 `afterRead` 훅에 비용이 많이 드는 로직을 넣는 것을 피하세요.

```ts
{
  hooks: {
    beforeRead: [
      async () => {
        // 이것은 모든 읽기 요청에서 실행됩니다 - 여기서는 비용이 많이 드는 로직을 피하세요
        await doSomethingExpensive()
        return data
      },
    ],
  },
}
```

대신 문서가 생성되거나 업데이트될 때만 실행되는 `beforeChange`나 `afterChange` 훅을 사용하고 싶을 수 있습니다.

```ts
{
  hooks: {
    beforeChange: [
      async ({ context }) => {
        // 여기서는 더 허용 가능하지만, 여전히 성능을 염두에 두어야 합니다
        await doSomethingExpensive()
        // ...
      },
    ]
  },
}
```

### 훅 컨텍스트 사용

[훅 컨텍스트](./context)를 사용하여 무한 루프를 방지하거나 동일한 요청의 여러 훅에서 비용이 많이 드는 작업을 반복하는 것을 피하세요.

```ts
{
  hooks: {
    beforeChange: [
      async ({ context }) => {
        const somethingExpensive = await doSomethingExpensive()
        context.somethingExpensive = somethingExpensive
        // ...
      },
    ],
  },
}
```

자세한 내용은 [훅 컨텍스트 문서](./context)를 참조하세요.

### 작업 큐로 오프로딩

훅이 요청 라이프사이클에 직접적으로 영향을 주지 않는 장시간 실행 작업을 수행하는 경우, [작업 큐](../jobs-queue/overview)로 오프로딩하는 것을 고려하세요. 이렇게 하면 작업이 완료될 때까지 기다리지 않고 요청이 계속 처리될 수 있습니다.

```ts
{
  hooks: {
    afterChange: [
      async ({ doc, req }) => {
        // 작업 큐로 오프로딩
        await req.payload.jobs.queue(...)
        // ...
      },
    ],
  },
}
```

자세한 내용은 [작업 큐 문서](../jobs-queue/overview)를 참조하세요.