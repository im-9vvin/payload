---
title: 2.0에서 3.0으로의 마이그레이션 가이드
label: 2.0에서 3.0으로의 마이그레이션 가이드
order: 10
desc: Payload 2.x 프로젝트를 3.0으로 마이그레이션하기 위한 업그레이드 가이드입니다.
keywords: local api, config, configuration, documentation, Content Management System, cms, headless, javascript, node, react
---

# Payload 2.0에서 3.0으로의 마이그레이션 가이드

Payload 3.0은 관리 패널을 React Router 단일 페이지 애플리케이션에서 React 서버 컴포넌트를 완전히 지원하는 Next.js App Router로 완전히 재플랫폼화했습니다. 이 변경사항은 Payload "코어"를 렌더링 및 HTTP 레이어로부터 완전히 분리하여 진정한 Node 안전성과 이식성을 제공합니다.

_이전 베타 버전_에서 업그레이드하는 경우, [이전 베타에서 업그레이드](#upgrade-from-previous-beta) 섹션을 참조하세요.

## 무엇이 바뀌었나요?

Payload의 핵심 로직과 원칙은 2.0에서 3.0까지 동일하게 유지되며, 대부분의 변경사항은 HTTP 레이어와 현재 Next.js를 기반으로 구축된 관리 패널에 특별히 영향을 미칩니다. 이 변경으로 전체 애플리케이션을 단일 저장소 내에서 제공할 수 있으며, Payload 엔드포인트는 이제 프론트엔드와 직접적으로 함께 자체 Next.js 애플리케이션 내에서 열립니다. Payload는 여전히 헤드리스이며, Sveltekit 등과 함께 현재 하고 있는 것처럼 완전히 헤드리스하게 활용할 수 있습니다. 모든 Payload API는 정확히 동일하게 유지되며(몇 가지 새로운 기능 포함), Payload Config는 일반적으로 동일하지만 아래에 자세히 설명된 주요 변경사항이 있습니다.

### 목차

모든 주요 변경사항이 아래에 나열되어 있습니다. 여기에 명시적으로 나열되지 않은 변경사항이 발생하면 PR을 제출하여 이 문서에 기여하는 것을 고려해 보세요.

- [설치](#installation)
- [주요 변경사항](#breaking-changes)
- [사용자 정의 컴포넌트](#custom-components)
- [엔드포인트](#endpoints)
- [React 훅](#react-hooks)
- [타입](#types)
- [이메일 어댑터](#email-adapters)
- [플러그인](#plugins)
- [이전 베타에서 업그레이드](#upgrade-from-previous-beta)

## 설치

Payload 3.0에는 기존 프로젝트에 가져와야 하는 자동 생성된 파일 세트가 필요합니다. 이를 획득하는 가장 쉬운 방법은 `create-payload-app`을 통해 새 프로젝트를 초기화한 다음 제공된 Payload Config를 자신의 것으로 교체하는 것입니다.

```bash
  npx create-payload-app
```

자세한 내용은 [문서](https://payloadcms.com/docs/getting-started/installation)를 참조하세요.

1. **Payload, Next.js 및 React의 새로운 의존성을 설치**:

   peerDependencies, devDependencies 및 dependencies를 포함하여 create-payload-app에서 만들어진 package.json 파일을 참조하세요. 코어 패키지와 플러그인은 모든 버전이 동기화되어야 합니다. 이전에 2.x에서는 예를 들어 db-mongodb의 이전 버전과 함께 Payload 2.x의 최신 버전을 실행할 수 있었습니다. 이제는 더 이상 그렇지 않습니다.

   ```bash
     pnpm i next react react-dom payload @payloadcms/ui @payloadcms/next
   ```

   또한 사용 중인 플러그인과 어댑터에 특정한 다른 @payloadcms 패키지도 설치하세요. 프로젝트에 따라 다음이 포함될 수 있습니다:

   - @payloadcms/db-mongodb
   - @payloadcms/db-postgres
   - @payloadcms/richtext-slate
   - @payloadcms/richtext-lexical
   - @payloadcms/plugin-form-builder
   - @payloadcms/plugin-nested-docs
   - @payloadcms/plugin-redirects
   - @payloadcms/plugin-relationship
   - @payloadcms/plugin-search
   - @payloadcms/plugin-sentry
   - @payloadcms/plugin-seo
   - @payloadcms/plugin-stripe
   - @payloadcms/plugin-cloud-storage - [자세히 알아보기](#@payloadcms/plugin-cloud-storage).

1. 사용되지 않는 패키지를 제거:

   ```bash
   pnpm remove express nodemon @payloadcms/bundler-webpack @payloadcms/bundler-vite
   ```

1. 데이터베이스 어댑터 마이그레이션

   _기존 데이터가 있고_ MongoDB 또는 Postgres 어댑터를 사용하는 경우, 데이터베이스 스키마가 최신인지 확인하기 위해 데이터베이스 마이그레이션을 실행해야 합니다.

   - [postgres](https://github.com/payloadcms/payload/releases/tag/v3.0.0-beta.39)
   - [mongodb](https://github.com/payloadcms/payload/releases/tag/v3.0.0-beta.131)

1. Payload Cloud 사용자의 경우, 플러그인이 변경되었습니다.

   기존 패키지를 제거:

   ```bash
   pnpm remove @payloadcms/plugin-cloud
   ```

   새 패키지를 설치:

   ```bash
   pnpm i @payloadcms/payload-cloud
   ```

   ```diff
   // payload.config.ts
   - import { payloadCloud } from '@payloadcms/plugin-cloud'
   + import { payloadCloudPlugin } from '@payloadcms/payload-cloud'

   buildConfig({
     // ...
     plugins: [
   -   payloadCloud()
   +   payloadCloudPlugin()
     ]
   })
   ```

1. **선택사항** sharp 의존성

   `formatOptions`, `imageSizes` 또는 `resizeOptions`를 사용하는 업로드 활성화된 컬렉션이 있는 경우—payload는 `sharp`가 설치되어 있을 것으로 예상합니다. 2.0에서는 이 의존성이 자동으로 설치되었습니다. 이제는 필요한 경우에만 설치됩니다. 이러한 옵션 중 하나라도 설정되어 있는 경우, `sharp`를 설치하고 payload.config.ts에 추가해야 합니다:

   ```bash
   pnpm i sharp
   ```

   ```diff
   // payload.config.ts
   import sharp from 'sharp'
   buildConfig({
   // ...
   +   sharp,
   })
   ```

## 주요 변경사항

1.  Payload Config에서 `admin.bundler` 속성을 삭제하세요. Payload는 더 이상 관리 패널을 번들링하지 않습니다. 대신, 번들링을 위해 Next.js에 직접 의존합니다.

    ```diff
    // payload.config.ts
    - import { webpackBundler } from '@payloadcms/bundler-webpack'

    buildConfig({
      // ...
      admin: {
        // ...
    -   bundler: webpackBundler(),
      }
    })
    ```

    이것은 또한 `@payloadcms/bundler-webpack` 및 `@payloadcms/bundler-vite` 패키지가 사용되지 않음을 의미합니다. `package.json` 파일에서 이를 제거하고 패키지 매니저의 설치 프로세스(예: `pnpm i`)를 다시 실행하여 프로젝트에서 완전히 제거할 수 있습니다.

1.  Payload Config에 `secret` 속성을 추가하세요. 이것은 이전에 `server.ts` 파일의 `payload.init()` 함수에서 설정되었습니다. 대신, `payload.config.ts`로 이동하세요:

    ```diff
    // payload.config.ts

    buildConfig({
      // ...
    + secret: process.env.PAYLOAD_SECRET
    })
    ```

1.  `PAYLOAD_PUBLIC`로 접두사가 붙은 환경 변수는 더 이상 클라이언트에서 사용할 수 없습니다. 클라이언트에서 액세스하려면 대신 `NEXT_PUBLIC`로 접두사를 붙여야 합니다.

    ```diff
    'use client'
    - const var = process.env.PAYLOAD_PUBLIC_MY_ENV_VAR
    + const var = process.env.NEXT_PUBLIC_MY_ENV_VAR
    ```

    자세한 내용은 [문서](https://payloadcms.com/docs/configuration/environment-vars)를 참조하세요.

1.  `req` 객체는 [Express Request](https://expressjs.com/)를 확장하는 데 사용되었지만 이제는 [Web Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)를 확장합니다. 이 변경사항을 반영하도록 코드를 업데이트해야 할 수 있습니다. 예를 들어:

    ```diff
    - req.headers['content-type']
    + req.headers.get('content-type')
    ```

1.  Payload Config의 `admin.css` 및 `admin.scss` 속성이 제거되었습니다.

    ```diff
    // payload.config.ts

    buildConfig({
      // ...
      admin: {
        // ...
    -   css: '',
    -   scss: ''
      }
    })
    ```

    마이그레이션하려면 다음 옵션 중 하나를 선택하세요:

    1. 대부분의 사용 사례에서는 `(payload)/custom.scss`에 위치한 파일을 간단히 사용자 정의할 수 있습니다. Tailwind 등을 위해 여기에 자신의 스타일을 가져오거나 추가할 수 있습니다.
    1. 플러그인 작성자의 경우, `admin.components.providers`에서 사용자 정의 Provider를 사용하여 스타일시트를 가져올 수 있습니다:

       ```tsx
       // payload.config.js

       //...
       admin: {
         components: {
           providers: [
             MyProvider: './providers/MyProvider.tsx'
           ]
         }
       },
       //...

       // providers/MyProvider.tsx

       'use client'
       import React from 'react'
       import './globals.css'

       export const MyProvider: React.FC<{children?: any}> = ({ children }) => {
         return (
           <React.fragment>
             {children}
           </React.fragment>
         )
       }
       ```

1.  `admin.indexHTML` 속성이 제거되었습니다. Payload Config에서 이를 삭제하세요.

    ```diff
    // payload.config.ts

    buildConfig({
      // ...
      admin: {
        // ...
    -   indexHTML: ''
      }
    })
    ```

1.  `collection.admin.hooks` 속성이 제거되었습니다. 대신, 일반적인 필드 훅 인수를 취하는 새로운 `beforeDuplicate` 필드 레벨 훅을 사용하세요.

    ```diff
    // collections/Posts.ts
    import type { CollectionConfig } from 'payload'

    export const PostsCollection: CollectionConfig = {
      slug: 'posts',
      admin: {
        hooks: {
    -     beforeDuplicate: ({ data }) => {
    -       return {
    -         ...data,
    -         title: `${data.title}-duplicate`
    -       }
    -     }
        }
      },
      fields: [
        {
          name: 'title',
          type: 'text',
          hooks: {
    +      beforeDuplicate: [
    +        ({ data }) => `${data.title}-duplicate`
    +      ],
          },
        },
      ],
    }
    ```

1.  `unique: true`가 있는 필드는 이제 새로운 `admin.beforeDuplicate` 필드 훅을 통해 자동으로 "- Copy"가 추가됩니다(이전 불릿 참조).

1.  `upload.staticDir` 속성은 이제 절대 경로여야 합니다. 이전에는 Payload Config의 위치를 사용하고 staticDir에 설정된 상대 경로와 병합을 시도했습니다.

    ```diff
    // collections/Media.ts
    import type { CollectionConfig } from 'payload'
    import path from 'path'
    + import { fileURLToPath } from 'url'

    + const filename = fileURLToPath(import.meta.url)
    + const dirname = path.dirname(filename)

    export const MediaCollection: CollectionConfig = {
      slug: 'media',
      upload: {
    -   staticDir: path.resolve(__dirname, './uploads'),
    +   staticDir: path.resolve(dirname, '../uploads'),
      },
    }
    ```

1.  `upload.staticURL` 속성이 제거되었습니다. 외부 제공자를 사용할 때 URL을 포맷하기 위해 이를 사용하고 있었다면, 동일한 작업을 수행하기 위해 `generateFileURL` 함수를 활용할 수 있습니다.

    ```diff
    // collections/Media.ts
    import type { CollectionConfig } from 'payload'

    export const MediaCollection: CollectionConfig = {
      slug: 'media',
      upload: {
    -   staticURL: '',
      },
    }
    ```

1.  `admin.favicon` 속성은 이제 `admin.icons`이며 타입이 변경되었습니다:

    ```diff
    // payload.config.ts
    import { buildConfig } from 'payload'

    const config = buildConfig({
      // ...
      admin: {
    -   favicon: 'path-to-favicon.svg',
    +   icons: [{
    +     path: 'path-to-favicon.svg',
    +     sizes: '32x32'
    +   }]
      }
    })
    ```

    자세한 내용은 [문서](https://payloadcms.com/docs/admin/metadata#icons)를 참조하세요.

1.  `admin.meta.ogImage` 속성이 `admin.meta.openGraph.images`로 교체되었습니다:

    ```diff
    // payload.config.ts
    import { buildConfig } from 'payload'

    const config = buildConfig({
      // ...
      admin: {
        meta: {
    -     ogImage: '',
    +     openGraph: {
    +       images: []
    +     }
        }
      }
    })
    ```

    자세한 내용은 [문서](https://payloadcms.com/docs/admin/metadata#open-graph)를 참조하세요.

1.  `admin.livePreview.url` 함수의 인수가 변경되었습니다. 더 이상 `documentInfo`를 인수로 받지 않고, 대신 `collectionConfig`와 `globalConfig`를 가집니다.

    ```diff
    // payload.config.ts
    import { buildConfig } from 'payload'

    export default buildConfig({
      // ...
      admin: {
        // ...
        livePreview: ({
    -     documentInfo,
    +     collectionConfig,
    +     globalConfig
        }) => ''
      }
    })
    ```

1.  `admin.logoutRoute` 및 `admin.inactivityRoute` 속성이 단일 `admin.routes` 속성으로 통합되었습니다. 마이그레이션하려면 다음과 같이 해당 두 키를 이동하기만 하면 됩니다:

    ```diff
    // payload.config.ts
    import { buildConfig } from 'payload'

    const config = buildConfig({
      // ...
      admin: {
    -   logoutRoute: '/custom-logout',
    -   inactivityRoute: '/custom-inactivity'
    +   routes: {
    +     logout: '/custom-logout',
    +     inactivity: '/custom-inactivity'
    +   }
      }
    })
    ```

1.  Payload Config(예: Collections, Globals, Fields)의 `custom` 속성은 이제 **서버 전용**이며 클라이언트 측 번들에 **나타나지 않습니다**. 클라이언트 번들에 사용자 정의 속성을 추가하려면 _서버와 클라이언트_ 모두에서 사용할 수 있는 새로운 `admin.custom` 속성을 사용하세요.

    ```diff
    // payload.config.ts
    import { buildConfig } from 'payload'

    export default buildConfig({
      custom: {
        someProperty: 'My Server Prop' // 이제 서버 전용!
      },
      admin: {
    +   custom: {
    +     name: 'My Client Prop' // 서버와 클라이언트에서 모두 사용 가능
    +   }
      },
    })
    ```

1.  `hooks.afterError`는 이제 단일 함수 대신 함수 배열입니다. 인수도 확장되었습니다. [자세히 알아보기](https://payloadcms.com/docs/hooks/overview#root-hooks).

    ```diff
    // payload.config.ts
    import { buildConfig } from 'payload'

    export default buildConfig({
      hooks: {
    -   afterError: async ({ error }) => {
    +   afterError: [
    +     async ({ error, req, res }) => {
    +       // ...
    +     }
    +   ]
      }
    })
    ```

1.  `./src/public` 디렉터리는 이제 루트 레벨 `./public`에 직접 위치합니다 [자세한 내용은 Next.js 문서를 참조하세요](https://nextjs.org/docs/pages/building-your-application/optimizing/static-assets)

1.  부모가 지역화된 경우 하위 필드에서 `localized: true` 속성을 자동으로 제거합니다(중복되고 불필요하기 때문). 이 구조에 기존 데이터가 있고 해당 동작을 비활성화하려면 payload.config에서 `allowLocalizedWithinLocalized` 플래그를 활성화해야 합니다 [문서에서 자세히 읽어보기](https://payloadcms.com/docs/configuration/overview#compatibility-flags), 또는 데이터를 정렬하는 마이그레이션 스크립트를 생성하세요.
    페이지 레이아웃의 링크에 대한 Mongodb 예제입니다.

        ```diff
        - layout.columns.en.link.en.type.en
        + layout.columns.en.link.type
        ```

## 사용자 정의 컴포넌트

1. 모든 Payload React 컴포넌트가 `payload` 패키지에서 `@payloadcms/ui`로 이동되었습니다. 이전에 사용자 정의 컴포넌트를 생성하기 위해 `payload` 패키지에서 컴포넌트를 앱으로 가져오고 있었다면, 가져오기 경로를 변경해야 합니다:

   ```diff
   - import { TextField, useField, etc. } from 'payload'
   + import { TextField, useField, etc. } from '@payloadcms/ui'
   ```

   _참고: 간결함을 위해 *모든* 모듈이 여기에 나열되지는 않았습니다._

1. 모든 사용자 정의 컴포넌트는 이제 직접 가져오기 대신 _파일 경로_로 정의됩니다. Payload Config에서 사용자 정의 컴포넌트를 사용하고 있다면, 가져온 모듈을 제거하고 대신 파일의 경로를 가리키세요:

   ```diff
   import { buildConfig } from 'payload'
   - import { MyComponent } from './src/components/Logout'

   const config = buildConfig({
     // ...
     admin: {
       components: {
         logout: {
   -       Button: MyComponent,
   +       Button: '/src/components/Logout#MyComponent'
         }
       }
     },
   })
   ```

   자세한 내용은 [문서](https://payloadcms.com/docs/custom-components/overview#component-paths)를 참조하세요.

1. 모든 사용자 정의 컴포넌트는 이제 기본적으로 서버에서 렌더링되므로 state나 훅을 직접 사용할 수 없습니다. state나 훅이 필요한 사용자 정의 컴포넌트를 앱에서 사용하고 있다면, 파일 상단에 `'use client'` 지시문을 추가하세요.

   ```diff
   // components/MyClientComponent.tsx
   + 'use client'
   import React, { useState } from 'react'

   export const MyClientComponent = () => {
     const [state, setState] = useState()

     return (
       <div>
         {state}
       </div>
     )
   }
   ```

   자세한 내용은 [문서](https://payloadcms.com/docs/custom-components/overview#client-components)를 참조하세요.

1. Collection, Globals 및 Fields 내의 `admin.description` 속성은 더 이상 React 컴포넌트를 허용하지 않습니다. 대신, 사용자 정의 컴포넌트로 정의해야 합니다.

   1. Collections의 경우, `admin.components.edit.Description` 키를 사용:

   ```diff
   // collections/Posts.ts
   import type { CollectionConfig } from 'payload'
   - import { MyCustomDescription } from '../components/MyCustomDescription'

   export const PostsCollection: CollectionConfig = {
     slug: 'posts',
     admin: {
   -    description: MyCustomDescription,
   +    components: {
   +      edit: {
   +        Description: 'path/to/MyCustomDescription'
   +      }
   +    }
     }
   }
   ```

   2. Globals의 경우, `admin.components.elements.Description` 키를 사용:

   ```diff
   // globals/Site.ts
   import type { GlobalConfig } from 'payload'
   - import { MyCustomDescription } from '../components/MyCustomDescription'

   export const SiteGlobal: GlobalConfig = {
     slug: 'site',
     admin: {
   -    description: MyCustomDescription,
   +    components: {
   +      elements: {
   +        Description: 'path/to/MyCustomDescription'
   +      }
   +    }
     }
   }
   ```

   3. Fields의 경우, `admin.components.Description` 키를 사용:

   ```diff
   // fields/MyField.ts
   import type { FieldConfig } from 'payload'
   - import { MyCustomDescription } from '../components/MyCustomDescription'

   export const MyField: FieldConfig = {
     type: 'text',
     admin: {
   -    description: MyCustomDescription,
   +    components: {
   +      Description: 'path/to/MyCustomDescription'
   +    }
     }
   }
   ```

1. 배열 필드 행 라벨과 접을 수 있는 필드 라벨은 이제 _오직_ React 컴포넌트만 허용하며, 더 이상 평문 문자열이나 레코드를 허용하지 않습니다:

   ```diff
   // file: Collection.tsx
   import type { CollectionConfig } from 'payload'
   - import { MyCustomRowLabel } from './components/MyCustomRowLabel.tsx'

   export const MyCollection: CollectionConfig = {
     slug: 'my-collection',
     fields: [
       {
         name: 'my-array',
         type: 'array',
         admin: {
           components: {
   -         RowLabel: 'My Array Row Label,
   +         RowLabel: './components/RowLabel.ts'
           }
         },
         fields: [...]
       },
       {
         name: 'my-collapsible',
         type: 'collapsible',
         admin: {
           components: {
   -         Label: 'My Collapsible Label',
   +         Label: './components/RowLabel.ts'
           }
         },
         fields: [...]
       }
     ]
   }
   ```

1. 모든 기본 뷰 키는 이제 camelCase입니다:

   예를 들어, 루트 뷰의 경우:

   ```diff
   // file: payload.config.ts

   import { buildConfig } from 'payload'

   export default buildConfig({
   admin: {
     views: {
   -    Account: ...
   +    account: ...
     }
   })
   ```

   또는 문서 뷰:

   ```diff
   // file: Collection.tsx

   import type { CollectionConfig } from 'payload'

   export const MyCollection: CollectionConfig = {
     slug: 'my-collection',
     admin: {
       views: {
   -     Edit: {
   -       Default: ...
   -     }
   +     edit: {
   +       default: ...
   +     }
       }
     }
   }
   ```

1. 구성 내의 사용자 정의 뷰는 더 이상 React 컴포넌트를 직접 허용하지 않으며, 대신 `Component` 속성을 사용해야 합니다:

   ```diff
   // file: Collection.tsx
   import type { CollectionConfig } from 'payload'
   - import { MyCustomView } from './components/MyCustomView.tsx'

   export const MyCollection: CollectionConfig = {
     slug: 'my-collection',
     admin: {
       views: {
   -     Edit: MyCustomView
   +     edit: {
   +       Component: './components/MyCustomView.tsx'
   +     }
       }
     }
   }
   ```

   이는 또한 사용자 정의 루트 뷰가 더 이상 `edit` 키에 정의되지 않음을 의미합니다. 대신, 새로운 `views.root` 키를 사용하세요:

   ```diff
   // file: Collection.tsx
   import type { CollectionConfig } from 'payload'
   - import { MyCustomRootView } from './components/MyCustomRootView.tsx'

   export const MyCollection: CollectionConfig = {
     slug: 'my-collection',
     admin: {
       views: {
   -     Edit: MyCustomRootView
         edit: {
   +       root: {
   +         Component: './components/MyCustomRootView.tsx'
   +       }
         }
       }
     }
   }
   ```

1. 뷰 탭의 `href` 및 `isActive` 함수는 더 이상 `match` 또는 `location` 인수를 포함하지 않습니다. 이는 Next.js가 아닌 React Router에 특정한 속성입니다. 이와 유사한 URL 매칭을 해야 한다면, 일부 훅(예: `usePathname()`)을 실행하는 사용자 정의 탭을 사용하고 자체 유틸리티 함수를 통해 실행하세요:

   ```diff
   // collections/Posts.ts
   import type { CollectionConfig } from 'payload'

   export const PostsCollection: CollectionConfig = {
     slug: 'posts',
     admin: {
       components: {
         views: {
   -        Edit: {
   -          Tab: {
   -            isActive: ({ href, location, match }) => true,
   -            href: ({ href, location, match }) => ''
   -          },
   -       },
   +       edit: {
   +         tab: {
   +           isActive: ({ href }) => true,
   +           href: ({ href }) => '' // 또는 사용자 정의 컴포넌트 사용 (아래 참조)
   +           // Component: './path/to/CustomComponent.tsx'
   +         }
   +       },
         },
       },
     },
   }
   ```

1. `admin.components.views[key].Tab.pillLabel`이 `admin.components.views[key].tab.Pill`로 교체되었습니다:

   ```diff
   // collections/Posts.ts
   import type { CollectionConfig } from 'payload'

   export const PostsCollection: CollectionConfig = {
     slug: 'posts',
     admin: {
       components: {
   -     views: {
   -       Edit: {
   -         Tab: {
   -           pillLabel: 'Hello, world!',
   -         },
   -       },
   +       edit: {
   +         tab: {
   +           Pill: './path/to/CustomPill.tsx',
   +         }
   +       },
         },
       },
     },
   }
   ```

1. `react-i18n`이 제거되었고, `react-i18n`의 `Trans` 컴포넌트가 Payload에서 제공하는 솔루션으로 교체되었습니다:

   ```diff
   'use client'
   - import { Trans } from "react-i18n"
   + import { Translation } from "@payloadcms/ui"

   // 번역할 예제 문자열:
   // "loggedInChangePassword": "To change your password, go to your <0>account</0> and edit your password there."

   export const MyComponent = () => {
     return (
   -     <Trans i18nKey="loggedInChangePassword" t={t}>
   -       <Link to={`${admin}/account`}>account</Link>
   -     </Trans>

   +     <Translation
   +       t={t}
   +       i18nKey="authentication:loggedInChangePassword"
   +       elements={{
   +         '0': ({ children }) => <Link href={`${admin}/account`} children={children} />,
   +       }}
   +     />
     )
   }
   ```

## 엔드포인트

1. 모든 엔드포인트 핸들러가 변경되었습니다. 인수에 더 이상 `res` 및 `next`가 포함되지 않으며, 반환 타입은 이제 `res.json`, `res.send` 등 대신 유효한 HTTP [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)를 기대합니다:

   ```diff
   // collections/Posts.ts
   import type { CollectionConfig } from 'payload'

   export const PostsCollection: CollectionConfig = {
     slug: 'posts',
     endpoints: [
   -   {
   -     path: '/whoami/:parameter',
   -     method: 'post',
   -     handler: (req, res) => {
   -       res.json({
   -         parameter: req.params.parameter,
   -         name: req.body.name,
   -         age: req.body.age,
   -       })
   -     }
   -   },
   +   {
   +     path: '/whoami/:parameter',
   +     method: 'post',
   +     handler: (req) => {
   +       return Response.json({
   +         parameter: req.routeParams.parameter,
   +         // ^^ `params`는 이제 `routeParams`입니다
   +         name: req.data.name,
   +         age: req.data.age,
   +       })
   +     }
   +   }
     ]
   }
   ```

1. 엔드포인트 핸들러는 더 이상 요청에서 `data`, `locale` 또는 `fallbackLocale`을 해결해주지 않습니다. 대신, 직접 해결하거나 Payload에서 제공하는 유틸리티를 사용해야 합니다:

   ```diff
   // collections/Posts.ts
   import type { CollectionConfig } from 'payload'
   + import { addDataAndFileToRequest } from '@payloadcms/next/utilities'
   + import { addLocalesToRequest } from '@payloadcms/next/utilities'

   export const PostsCollection: CollectionConfig = {
     slug: 'posts',
     endpoints: [
   -   {
   -     path: '/whoami/:parameter',
   -     method: 'post',
   -     handler: async (req) => {
   -       return Response.json({
   -         name: req.data.name, // data는 정의되지 않습니다
   -       })
   -     }
   -   },
   +   {
   +     path: '/whoami/:parameter',
   +     method: 'post',
   +     handler: async (req) => {
   +       // req를 변경하므로 await해야 합니다
   +       await addDataAndFileToRequest(req)
   +       await addLocalesToRequest(req)
   +
   +       return Response.json({
   +         name: req.data.name, // data를 이제 사용할 수 있습니다
   +    	    fallbackLocale: req.fallbackLocale,
   +         locale: req.locale,
   +       })
   +     }
   +   }
     ]
   }
   ```

## React 훅

1. `useTitle` 훅이 `useDocumentInfo` 훅으로 통합되었습니다. 대신, 문서 정보 컨텍스트에서 직접 제목을 가져올 수 있습니다:

   ```diff
   'use client'
   - import { useTitle } from 'payload'
   + import { useDocumentInfo } from '@payloadcms/ui'

   export const MyComponent = () => {
   - const title = useTitle()
   + const { title } = useDocumentInfo()

     // ...
   }
   ```

1. `useDocumentInfo` 훅은 더 이상 `collection` 또는 `global`을 반환하지 않습니다. 대신, `collectionSlug` 및 `globalSlug`와 같은 구성의 다양한 속성이 전달됩니다. 필요한 경우 `useConfig` 훅을 통해 클라이언트 측 구성에 액세스하는 데 사용할 수 있습니다(다음 불릿 참조).

   ```diff
   'use client'
   import { useDocumentInfo } from '@payloadcms/ui'

   export const MyComponent = () => {
     const {
   -   collection,
   -   global,
   +   collectionSlug,
   +   globalSlug
     } = useDocumentInfo()

     // ...
   }
   ```

1. `useConfig` 훅은 이제 `SanitizedConfig`가 아닌 `ClientConfig`를 반환합니다. 구성 자체가 직렬화 가능하지 않아 클라이언트로 스레드할 수 없기 때문입니다. 즉, `db`, `bundler` 등과 같이 직렬화할 수 없는 모든 prop이 Client Config에서 생략되었음을 의미합니다.

   ```diff
   'use client'
   - import { useConfig } from 'payload'
   + import { useConfig } from '@payloadcms/ui'

   export const MyComponent = () => {
   - const config = useConfig() // 이전에는 'SanitizedConfig'였습니다
   + const { config } = useConfig() // 이제는 'ClientConfig'입니다

     // ...
   }
   ```

   자세한 내용은 [문서](https://payloadcms.com/docs/admin/custom-components/overview#accessing-the-payload-config)를 참조하세요.

1. `useCollapsible` 훅의 속성 이름이 약간 변경되었습니다. `collapsed`는 이제 `isCollapsed`이고 `withinCollapsible`은 이제 `isWithinCollapsible`입니다.

   ```diff
   'use client'
   import { useCollapsible } from '@payloadcms/ui'

   export const MyComponent = () => {
   - const { collapsed, withinCollapsible } = useCollapsible()
   + const { isCollapsed, isWithinCollapsible } = useCollapsible()
   }
   ```

1. `useTranslation` 훅은 더 이상 옵션을 취하지 않으며, 간단한 접근자를 사용하는 모든 번역은 전체 `group:key`를 사용해야 합니다

   ```diff
   'use client'
   - import { useTranslation } from 'payload'
   + import { useTranslation } from '@payloadcms/ui'

   export const MyComponent = () => {
   - const { i18n, t } = useTranslation('general')
   + const { i18n, t } = useTranslation()

   - return <p>{t('cancel')}</p>
   + return <p>{t('general:cancel')}</p>
   }
   ```

## 타입

1. `Fields` 타입이 향상된 의미를 위해 `FormState`로 이름이 변경되었습니다. 이전에 자체 애플리케이션에서 이 타입을 가져오고 있었다면, 간단히 가져오기 이름을 변경하세요:

   ```diff
   - import type { Fields } from 'payload'
   + import type { FormState } from 'payload'
   ```

1. `BlockField` 및 관련 타입이 의미론적 정확성을 위해 `BlocksField`로 이름이 변경되었습니다.

   ```diff
   - import type { BlockField, BlockFieldProps } from 'payload'
   + import type { BlocksField, BlocksFieldProps } from 'payload'
   ```

## 이메일 어댑터

이메일 기능이 이메일 어댑터로 추상화되었습니다.

- 모든 기존 nodemailer 기능이 `@payloadcms/email-nodemailer` 패키지로 추상화되었습니다
- 더 이상 기본적으로 ethereal.email로 구성되지 않습니다.
- `init` 함수에 이메일을 전달하는 능력이 제거되었습니다.
- 이메일이 구성되지 않은 경우 시작 시 경고가 표시됩니다. 모든 `sendEmail` 호출은 단순히 받는 사람 주소와 제목을 로그합니다.
- Resend 어댑터도 이제 `@payloadcms/email-resend` 패키지를 통해 사용할 수 있습니다.

### 2.0에서 기본 이메일 구성을 사용한 경우 (nodemailer):

```tsx
// ❌ 이전

// payload.init을 통해
payload.init({
  email: {
    transport: someNodemailerTransport
    fromName: 'hello',
    fromAddress: 'hello@example.com',
  },
})
// 또는 payload.config.ts의 email을 통해
export default buildConfig({
  email: {
    transport: someNodemailerTransport
    fromName: 'hello',
    fromAddress: 'hello@example.com',
  },
})

// ✅ 이후

// 새로운 nodemailer 어댑터 패키지 사용

import { nodemailerAdapter } from '@payloadcms/email-nodemailer'

export default buildConfig({
  email: nodemailerAdapter() // 이것은 이전의 ethereal.email 기능입니다
})

// 또는 transport를 전달

export default buildConfig({
  email: nodemailerAdapter({
    defaultFromAddress: 'info@payloadcms.com',
    defaultFromName: 'Payload',
    transport: await nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: 587,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS,
      },
    })
  })
})
```

### 속도 제한 제거

- 이제 사용자 정의 서버를 사용하고 express 또는 유사한 것을 사용하는 경우에만 사용 가능합니다

## 플러그인

1. _모든_ 플러그인이 (기본 내보내기가 아닌) _명명된 내보내기_를 사용하도록 표준화되었습니다. 대부분은 또한 가져오는 것이 무엇인지 명확히 하기 위해 `Plugin`의 접미사를 가집니다.

   ```diff
   - import seo from '@payloadcms/plugin-seo'
   + import { seoPlugin } from '@payloadcms/plugin-seo'

   - import stripePlugin from '@payloadcms/plugin-stripe'
   + import { stripePlugin } from '@payloadcms/plugin-stripe'

   // 모든 플러그인에 대해서도 마찬가지
   ```

## `@payloadcms/plugin-cloud-storage`

- `@payloadcms/plugin-cloud-storage` (즉, `@payloadcms/plugin-cloud-storage/s3`) 패키지에서 내보내는 어댑터가 제거되었습니다.
- 기존 어댑터 각각에 대해 새로운 _독립형_ 패키지가 생성되었습니다. 사용하는 것에 대한 문서를 참조하세요.
- `@payloadcms/plugin-cloud-storage`는 여전히 완전히 지원되지만 전용 패키지가 없는 사용자 정의 어댑터를 제공하는 경우에만 사용해야 합니다.
- 사용자 정의 어댑터를 생성한 경우, 타입은 이제 `name` 속성을 제공해야 합니다.

| Service              | Package                                                                      |
| -------------------- | ---------------------------------------------------------------------------- |
| Vercel Blob          | https://github.com/payloadcms/payload/tree/main/packages/storage-vercel-blob |
| AWS S3               | https://github.com/payloadcms/payload/tree/main/packages/storage-s3          |
| Azure                | https://github.com/payloadcms/payload/tree/main/packages/storage-azure       |
| Google Cloud Storage | https://github.com/payloadcms/payload/tree/main/packages/storage-gcs         |

```tsx
// ❌ 이전 (어댑터에 따라 필요한 peer dependencies)

import { cloudStorage } from '@payloadcms/plugin-cloud-storage'
import { s3Adapter } from '@payloadcms/plugin-cloud-storage/s3'

plugins: [
    cloudStorage({
      collections: {
        media: {
          adapter: s3Adapter({
            bucket: process.env.S3_BUCKET,
            config: {
              credentials: {
                accessKeyId: process.env.S3_ACCESS_KEY_ID,
                secretAccessKey: process.env.S3_SECRET_ACCESS_KEY,
              },
              region: process.env.S3_REGION,
            },
          }),
        },
      },
    }),
  ],

 // ✅ 이후

 import { s3Storage } from '@payloadcms/storage-s3'

 plugins: [
    s3Storage({
      collections: {
        media: true,
      },
      bucket: process.env.S3_BUCKET,
      config: {
        credentials: {
          accessKeyId: process.env.S3_ACCESS_KEY_ID,
          secretAccessKey: process.env.S3_SECRET_ACCESS_KEY,
        },
        region: process.env.S3_REGION,
      },
    }),
  ],
```

## `@payloadcms/plugin-form-builder`

1. 양식 및 양식 제출 컬렉션에 대한 필드 재정의는 이제 구성 배열 대신 인수 내부에 `defaultFields`가 있는 함수를 허용합니다

   ```diff
   // payload.config.ts
   import { buildConfig } from 'payload'
   import { formBuilderPlugin } from '@payloadcms/plugin-form-builder'

   const config = buildConfig({
     // ...
     plugins: formBuilderPlugin({
   -   fields: [
   -     {
   -       name: 'custom',
   -       type: 'text',
   -     }
   -   ],
   +   fields: ({ defaultFields }) => {
   +     return [
   +       ...defaultFields,
   +       {
   +         name: 'custom',
   +         type: 'text',
   +       },
   +     ]
   +   }
     })
   })
   ```

## `@payloadcms/plugin-redirects`

1. 리디렉트 컬렉션에 대한 필드 재정의는 이제 구성 배열 대신 인수 내부에 `defaultFields`가 있는 함수를 허용합니다

   ```diff
   // payload.config.ts
   import { buildConfig } from 'payload'
   import { redirectsPlugin } from '@payloadcms/plugin-redirects'

   const config = buildConfig({
     // ...
     plugins: redirectsPlugin({
   -   fields: [
   -     {
   -       name: 'custom',
   -       type: 'text',
   -     }
   -   ],
   +   fields: ({ defaultFields }) => {
   +     return [
   +       ...defaultFields,
   +       {
   +         name: 'custom',
   +         type: 'text',
   +       },
   +     ]
   +   }
     })
   })
   ```

## `@payloadcms/richtext-lexical`

`@payloadcms/richtext-lexical`에 대한 사용자 정의 기능이 있는 경우 새 API로 코드를 마이그레이션해야 합니다. 새 API에 대한 자세한 내용은 [문서](https://payloadcms.com/docs/rich-text/building-custom-features)를 참조하세요.

## 예약된 필드 이름

Payload는 내부 사용을 위해 특정 필드 이름을 예약합니다. 컬렉션이나 글로벌에서 다음 이름 중 하나를 사용하면 해당 필드가 구성에서 삭제되어 배포 오류가 발생할 수 있습니다. 마이그레이션하기 전에 충돌하는 필드의 이름을 바꾸었는지 확인하세요.

### 일반 예약 이름

- `file`
- `_id` (MongoDB 전용)
- `__v` (MongoDB 전용)

**중요 참고사항**: 플러그인에서 명시적으로 요구하지 않는 한 밑줄(`_`) 접두사가 있는 필드 이름 사용을 피하는 것이 좋습니다. Payload는 내부 열에 이 접두사를 사용하므로 특정 SQL 조건에서 충돌이 발생할 수 있습니다. 다음은 예약된 내부 열의 예입니다(이 목록은 완전하지 않으며 다른 내부 필드도 적용될 수 있습니다):

- `_order`
- `_path`
- `_uuid`
- `_parent_id`
- `_locale`

### 인증 관련 예약 이름

컬렉션에서 `auth: true`를 사용하고 `disableAuthStrategy: true`가 없는 경우 제한됩니다:

- `salt`
- `hash`
- `apiKey` (`auth.useAPIKey: true`가 활성화된 경우)
- `useAPIKey` (`auth.useAPIKey: true`가 활성화된 경우)
- `resetPasswordToken`
- `resetPasswordExpiration`
- `password`
- `email`
- `username`

### 업로드 관련 예약 이름

컬렉션에 `upload: true`가 구성된 경우 적용됩니다:

- `filename`
- `mimetype`
- `filesize`
- `width`
- `height`
- `focalX`
- `focalY`
- `url`
- `thumbnailURL`

`imageSizes`가 구성된 경우, 다음도 예약됩니다:

- `sizes`

이러한 이름 중 하나라도 컬렉션/글로벌 필드에서 발견되면 예상치 못한 문제를 피하기 위해 마이그레이션하기 전에 업데이트하세요.

## 이전 베타에서 업그레이드

이 [커뮤니티 제작 사이트](https://payload-releases-filter.vercel.app/?version=3&from=152429656&to=188243150&sort=asc&breaking=on)를 참조하세요. 버전을 설정하고, 가장 오래된 것부터 정렬하고, 주요 변경사항만 활성화하세요.

그런 다음 각각의 주요 변경사항을 검토하고 조정하세요. 선택적으로 [빈 템플릿](https://github.com/payloadcms/payload/tree/main/templates/blank)을 참조하여 최종 결과가 어떻게 되어야 하는지 확인할 수 있습니다.