---
title: 문서 쿼리하기
label: 개요
order: 10
desc: Payload는 모든 API를 통해 쿼리 언어를 제공하여 컬렉션 내의 문서를 필터링하거나 검색할 수 있게 해줍니다.
keywords: query, documents, overview, documentation, Content Management System, cms, headless, javascript, node, react, nextjs
---

Payload에서 "쿼리"는 [컬렉션](../configuration/collections) 내의 문서를 필터링하거나 검색하는 것을 의미합니다. Payload의 쿼리 언어는 직관적이고 표준화된 구조를 통해 매우 정밀하게 문서를 필터링할 수 있도록 간단하면서도 강력하게 설계되었습니다.

Payload는 데이터 쿼리를 위한 세 가지 일반적인 API를 제공합니다:

- [로컬 API](/docs/local-api/overview) - 매우 빠른 데이터베이스 직접 접근
- [REST API](/docs/rest-api/overview) - 데이터 쿼리 및 변경을 위한 표준 HTTP 엔드포인트
- [GraphQL](/docs/graphql/overview) - GraphQL Playground가 포함된 완전한 GraphQL API

이러한 API들은 모두 동일한 기본 쿼리 언어를 공유하며, 모든 동일한 기능을 완전히 지원합니다. 즉, Payload의 쿼리 언어를 한 번 배우면 사용할 수 있는 모든 API에서 사용할 수 있습니다.

문서를 쿼리하려면 요청을 통해 임의의 수의 [연산자](#operators)를 보낼 수 있습니다:

```ts
import type { Where } from 'payload'

const query: Where = {
  color: {
    equals: 'blue',
  },
}
```

_정확한 쿼리 구문은 사용하는 API에 따라 다르지만, 모든 API에서 개념은 동일합니다. [자세한 내용](#writing-queries)._

<Banner>
  **팁:** 쿼리는 [접근 제어](../access-control/overview) 함수 내에서도 사용할 수 있습니다.
</Banner>

## 연산자

쿼리에서 사용할 수 있는 연산자는 다음과 같습니다:

| 연산자               | 설명                                                                                                                                                                        |
| -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `equals`             | 값이 정확히 같아야 합니다.                                                                                                                                                 |
| `not_equals`         | 값이 같지 않은 모든 문서를 쿼리가 반환합니다.                                                                                                                              |
| `greater_than`       | 숫자 또는 날짜 기반 필드용입니다.                                                                                                                                          |
| `greater_than_equal` | 숫자 또는 날짜 기반 필드용입니다.                                                                                                                                          |
| `less_than`          | 숫자 또는 날짜 기반 필드용입니다.                                                                                                                                          |
| `less_than_equal`    | 숫자 또는 날짜 기반 필드용입니다.                                                                                                                                          |
| `like`               | 대소문자를 구분하지 않는 문자열이 있어야 합니다. 단어의 문자열인 경우 모든 단어가 순서와 상관없이 있어야 합니다.                                                           |
| `contains`           | 입력된 값을 포함해야 하며, 대소문자를 구분하지 않습니다.                                                                                                                   |
| `in`                 | 값이 제공된 쉼표로 구분된 값 목록 내에서 찾아져야 합니다.                                                                                                                  |
| `not_in`             | 값이 제공된 쉼표로 구분된 값 목록 내에 있어서는 안 됩니다.                                                                                                                 |
| `all`                | 값이 쉼표로 구분된 목록의 모든 값을 포함해야 합니다. 참고: 현재 이 연산자는 MongoDB 어댑터에서만 지원됩니다.                                                              |
| `exists`             | 값이 존재하는(`true`) 또는 존재하지 않는(`false`) 문서만 반환합니다.                                                                                                       |
| `near`               | [Point 필드](../fields/point)와 관련된 거리용으로 `<경도>, <위도>, <미터 단위 최대 거리(nullable)>, <미터 단위 최소 거리(nullable)>`로 쉼표로 구분됩니다.                |
| `within`             | [Point 필드](../fields/point)용으로 GeoJSON에서 정의된 주어진 영역 내부에 포인트가 있는지를 기반으로 문서를 필터링합니다. [예제](../fields/point#querying-within)      |
| `intersects`         | [Point 필드](../fields/point)용으로 GeoJSON에서 정의된 주어진 영역과 포인트가 교차하는지를 기반으로 문서를 필터링합니다. [예제](../fields/point#querying-intersects) |

<Banner type="success">
  **팁:** 사용자가 특정 필드를 자주 쿼리할 것을 안다면, 필드 구성에 
  `index: true`를 추가하세요. 이는 해당 필드를 사용한 검색 속도를 
  크게 향상시킵니다. [자세한 내용](../database/indexes).
</Banner>

### And / Or 논리

간단한 쿼리 정의 외에도, AND / OR 논리를 사용하여 여러 쿼리를 결합할 수 있습니다. 이는 복잡한 쿼리를 생성하기 위해 필요한 만큼 깊게 중첩될 수 있습니다.

쿼리를 결합하려면 쿼리 객체에서 `and` 또는 `or` 키를 사용하세요:

```ts
import type { Where } from 'payload'

const query: Where = {
  or: [
    // highlight-line
    {
      color: {
        equals: 'mint',
      },
    },
    {
      and: [
        // highlight-line
        {
          color: {
            equals: 'white',
          },
        },
        {
          featured: {
            equals: false,
          },
        },
      ],
    },
  ],
}
```

평이한 영어로 쓰면, 위의 쿼리가 `find` 작업에 전달되면 `color`가 `mint`이거나 `color`가 `white`이고 `featured`가 false로 설정된 게시물을 찾는 것으로 번역됩니다.

### 중첩 속성

관계형 필드를 사용할 때 발생할 수 있는 중첩 속성을 작업할 때는 점 표기법을 사용하여 중첩 속성에 액세스할 수 있습니다. 예를 들어, `name: 'artists'`를 사용하여 `Artists` 컬렉션과 관련된 `artists` 필드가 있는 `Song` 컬렉션으로 작업할 때. 다음과 같이 컬렉션 `Artists` 내의 속성에 액세스할 수 있습니다:

```js
import type { Where } from 'payload'

const query: Where = {
  'artists.featured': {
    // 필터링할 중첩 속성 이름
    exists: true, // 사용할 연산자와 true여야 하는 불린 값
  },
}
```

## 쿼리 작성하기

Payload에서 쿼리를 작성하는 것은 모든 API에서 간단하고 일관성이 있으며, 구문에서 약간의 차이만 있을 뿐입니다.

### 로컬 API

[로컬 API](../local-api/overview)는 원시 쿼리 객체를 허용하는 `find` 작업을 지원합니다:

```ts
import type { Payload } from 'payload'

const getPosts = async (payload: Payload) => {
  const posts = await payload.find({
    collection: 'posts',
    where: {
      color: {
        equals: 'mint',
      },
    },
  })

  return posts
}
```

### GraphQL API

[GraphQL API](../graphql/overview)의 모든 `find` 쿼리는 원시 쿼리 객체를 허용하는 `where` 인수를 지원합니다:

```ts
query {
  Posts(where: { color: { equals: mint } }) {
    docs {
      color
    }
    totalDocs
  }
}
```

### REST API

[REST API](../rest-api/overview)를 사용하면 Payload 쿼리의 모든 기능을 사용할 수 있지만, 대신 쿼리 문자열로 작성됩니다:

**`https://localhost:3000/api/posts?where[color][equals]=mint`**

구문을 이해하려면 복잡한 URL 검색 문자열이 JSON 객체로 구문 분석된다는 것을 이해해야 합니다. 이것은 그리 나쁘지 않지만, 더 복잡한 쿼리는 불가피하게 작성하기가 더 어려워집니다.

이러한 이유로 매우 유용하고 어디에서나 사용되는 [`qs-esm`](https://www.npmjs.com/package/qs-esm) 패키지를 사용하여 JSON / 객체 형식의 쿼리를 쿼리 문자열로 구문 분석하는 것을 권장합니다:

```ts
import { stringify } from 'qs-esm'
import type { Where } from 'payload'

const query: Where = {
  color: {
    equals: 'mint',
  },
  // 이 쿼리는 훨씬 더 복잡할 수 있으며
  // qs-esm이 아름답게 처리할 것입니다
}

const getPosts = async () => {
  const stringifiedQuery = stringify(
    {
      where: query, // `qs-esm`이 `where` 속성도 추가하도록 보장하세요!
    },
    { addQueryPrefix: true },
  )

  const response = await fetch(
    `http://localhost:3000/api/posts${stringifiedQuery}`,
  )
  // 아래에서 응답을 계속 처리하세요...
}
```

## 성능

쿼리를 최적화할 수 있는 여러 가지 방법이 있습니다. 이러한 옵션 중 많은 것들이 전체적인 데이터베이스 오버헤드, 응답 크기, 및/또는 계산 부하에 직접적으로 영향을 미치며 성능을 크게 향상시킬 수 있습니다.

쿼리를 작성할 때 이러한 전략들을 가능한 한 많이 결합하여 쿼리가 가능한 한 성능이 좋도록 하세요.

<Banner type="success">
  더 많은 성능 팁은 [성능 문서](../performance/overview)를 참조하세요.
</Banner>

### 인덱스

자주 쿼리되거나 정렬되는 필드에 대해 [인덱스](../database/indexes)를 구축하세요.

쿼리가 실행될 때 데이터베이스는 해당 하나의 필드를 찾기 위해 전체 문서를 검색하지 않고, 대신 인덱스를 사용하여 데이터를 빠르게 찾을 것입니다.

이는 해당 필드의 필드 구성에 `index: true`를 추가하여 수행됩니다:

```ts
// 컬렉션 구성에서
{
  name: 'posts',
  fields: [
    {
      name: 'title',
      type: 'text',
      // highlight-start
      index: true, // title 필드에 인덱스 추가
      // highlight-end
    },
    // 다른 필드들...
  ],
}
```

자세한 내용은 [인덱스 문서](../database/indexes)를 참조하세요.

### 깊이

불필요한 관련 문서의 채우기를 피하기 위해 [깊이](./depth)를 필요한 수준으로만 설정하세요.

관계는 지정된 깊이까지만 채워지고, 해당 깊이를 넘어서는 관계는 관련 문서의 ID만 반환됩니다.

```ts
const posts = await payload.find({
  collection: 'posts',
  where: { ... },
  // highlight-start
  depth: 0, // 관련 문서의 ID만 반환
  // highlight-end
})
```

자세한 내용은 [깊이 문서](./depth)를 참조하세요.

### 제한

고유 필드에서 쿼리하는 경우와 같이 일치하는 문서의 수를 안정적으로 예측할 수 있다면 [제한](./pagination#limit)을 설정하세요.

```ts
const posts = await payload.find({
  collection: 'posts',
  where: {
    slug: {
      equals: 'unique-post-slug',
    },
  },
  // highlight-start
  limit: 1, // 하나의 문서만 반환되기를 기대
  // highlight-end
})
```

<Banner type="success">
  **팁:** 고유 필드로 쿼리할 때 최상의 성능을 위해 `pagination: false`와 
  함께 사용하세요.
</Banner>

자세한 내용은 [제한 문서](./pagination#limit)를 참조하세요.

### 선택

필요한 필드만 처리하고 반환하려면 [선택 API](./select)를 사용하세요.

이는 요청에서 반환되는 데이터의 양을 줄이고, 필드 훅 실행과 같이 선택되지 않은 필드의 처리도 건너뜁니다.

```ts
const posts = await payload.find({
  collection: 'posts',
  where: { ... },
  // highlight-start
  select: [{
    title: true,
  }],
  // highlight-end
```

이는 기본적인 예제이지만, 특정 필드 선택, 필드 제외 등을 포함하여 선택 API를 사용하는 많은 방법이 있습니다.

자세한 내용은 [선택 문서](./select)를 참조하세요.

### 페이지네이션

고유 필드에서 쿼리하는 경우와 같이 일치하는 문서의 수를 안정적으로 예측할 수 있다면 [페이지네이션을 비활성화](./pagination#disabling-pagination)하세요.

```ts
const posts = await payload.find({
  collection: 'posts',
  where: {
    slug: {
      equals: 'unique-post-slug',
    },
  },
  // highlight-start
  pagination: false, // 페이지네이션 없이 모든 일치하는 문서 반환
  // highlight-end
})
```

<Banner type="success">
  **팁:** 고유 필드로 쿼리할 때 최상의 성능을 위해 `limit: 1`과 함께 
  사용하세요.
</Banner>

자세한 내용은 [페이지네이션 문서](./pagination)를 참조하세요.