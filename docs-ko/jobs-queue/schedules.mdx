---
title: Job 스케줄
label: 스케줄
order: 60
desc: Payload를 사용하면 주기적으로 실행할 jobs를 예약할 수 있습니다
keywords: jobs queue, application framework, typescript, node, react, nextjs, scheduling, cron, schedule
---

Payload의 `schedule` 속성을 사용하면 cron 스케줄에 따라 정기적으로 Jobs를 대기열에 추가할 수 있습니다 - 매일, 매주, 매시간 또는 사용자 정의 간격으로. 이는 수동 개입 없이 자동으로 반복되어야 하는 작업이나 워크플로우에 이상적입니다.

Jobs 예약은 실행과 크게 다릅니다:

- **대기열 추가**: 예약은 cron 표현식에 따라 Job을 생성(대기열에 추가)하기만 합니다. 비즈니스 로직을 즉시 실행하지는 않습니다.
- **실행**: 실행은 autorun과 같은 Jobs runner를 통해 별도로 발생하거나, `payload.jobs.run()` 또는 `payload-jobs/run` 엔드포인트를 사용한 수동 호출을 통해 발생합니다.

반복되는 작업이나 워크플로우가 있는 경우에만 `schedule` 속성을 사용하세요. 미래에 한 번 실행할 단일 Job을 대기열에 추가하려면 대신 `waitUntil` 속성을 사용하세요.

## 사용 사례 예시

**정기적인 이메일 또는 알림**

야간 다이제스트, 주간 뉴스레터 또는 시간별 업데이트 전송.

**비성수기 시간대의 일괄 처리**

트래픽이 적은 시간대에 분석 데이터 처리 또는 정적 사이트 재구축.

**주기적인 데이터 동기화**

외부 API와 정기적으로 업데이트를 푸시하거나 풀.

## 스케줄 처리

실제로 jobs의 예약을 트리거하는 것(아래에서 볼 수 있는 예약 라이프사이클 실행)이 필요합니다. 기본적으로 `jobs.autorun` 구성과 `/api/payload-jobs/run`은 `autorun` 구성에서 지정된 큐에 대한 예약도 처리합니다.

`autorun` 구성에서 `disableScheduling: true`를 설정하거나 `/api/payload-jobs/run` 엔드포인트에 `disableScheduling=true`를 전달하여 이 동작을 비활성화할 수 있습니다. 이는 예를 들어 `/api/payload-jobs/handle-schedules` 엔드포인트나 `payload.jobs.handleSchedules()` 로컬 API 메서드를 호출하는 cron job이나 서버리스 함수를 사용하여 예약을 수동으로 처리하려는 경우에 유용합니다.## Tasks나 Workflows에서 스케줄 정의

스케줄은 `schedule` 속성을 사용하여 정의됩니다:

```ts
export type ScheduleConfig = {
  cron: string // 필수, 초 정밀도 지원
  queue: string // 필수, Jobs를 푸시할 큐
  hooks?: {
    // 예약 동작을 사용자 정의하기 위한 선택적 hooks
    beforeSchedule?: BeforeScheduleFn
    afterSchedule?: AfterScheduleFn
  }
}
```

### 스케줄 예시

다음 예시는 매일 자정에 Job을 대기열에 추가하도록 예약하는 것을 보여줍니다:

```ts
import type { TaskConfig } from 'payload'

export const SendDigestEmail: TaskConfig<'SendDigestEmail'> = {
  slug: 'SendDigestEmail',
  schedule: [
    {
      cron: '0 0 * * *', // 매일 자정에
      queue: 'nightly',
    },
  ],
  handler: async () => {
    await sendDigestToAllUsers()
  },
}
```

이 구성은 Job을 대기열에만 추가하며 즉시 실행하지는 않습니다. 대기열에 있는 Job을 실제로 실행하려면 Payload 구성에서 autorun을 구성해야 합니다(autorun은 서버리스 플랫폼에서는 사용하지 **않아야** 합니다):

```ts
export default buildConfig({
  jobs: {
    autoRun: [
      {
        cron: '* * * * *', // 매분 실행
        queue: 'nightly',
      },
    ],
    tasks: [SendDigestEmail],
  },
})
```

이렇게 하면 Payload의 스케줄러가 매일 자정에 자동으로 job을 `nightly` 큐에 추가합니다. autorun 구성은 매분마다 `nightly` 큐를 확인하고 실행해야 할 Jobs를 실행합니다.

## 예약 라이프사이클

예약 프로세스가 세부적으로 작동하는 방식은 다음과 같습니다:

1. **Cron 평가**: Payload(또는 `manual` 모드에서 외부 트리거)는 실행해야 할 스케줄을 식별합니다. 이를 위해
   각 예약된 작업이나 워크플로우가 마지막으로 실행된 시간에 대한 정보가 포함된 `payload-jobs-stats` 글로벌을 읽습니다.
2. **BeforeSchedule hook**:
   - 기본 beforeSchedule hook은 예약 시스템에 의해 대기열에 추가된 동일한 유형의 활성 또는 실행 가능한 jobs가 현재 얼마나 존재하는지 확인합니다.
     그러한 job이 존재하면 새로운 job 예약을 건너뜁니다.
   - 이 동작을 사용자 정의하기 위해 자체 `beforeSchedule` hook을 제공할 수 있습니다. 예를 들어, 여러 겹치는 Jobs를 허용하거나 Job 입력 데이터를 동적으로 설정할 수 있습니다.
3. **Job 대기열 추가**: Payload가 새 job을 대기열에 추가합니다. 이 job은 cron 표현식에 기반한 다음 예약 시간으로 `waitUntil`이 설정됩니다.
4. **AfterSchedule hook**:
   - 기본 afterSchedule hook은 Job의 마지막 예약 시간으로 `payload-jobs-stats` 글로벌 메타데이터를 업데이트합니다.
   - 사용자 정의 로깅, 메트릭 또는 기타 예약 후 작업을 위해 자체 afterSchedule hook을 제공할 수 있습니다.

## 동시성 및 입력 사용자 정의 (고급)

동시성을 더 제어하거나 예약 시점에서 Job 입력을 동적으로 설정하려고 할 수 있습니다. 예를 들어, 이전에 예약된 job이 아직 완료되지 않았더라도 여러 겹치는 Jobs의 예약을 허용하거나, Job 핸들러에 전달할 동적 데이터를 준비하는 경우:

```ts
import { countRunnableOrActiveJobsForQueue } from 'payload'

schedule: [
  {
    cron: '* * * * *', // 매분마다
    queue: 'reports',
    hooks: {
      beforeSchedule: async ({ queueable, req }) => {
        const runnableOrActiveJobsForQueue =
          await countRunnableOrActiveJobsForQueue({
            queue: queueable.scheduleConfig.queue,
            req,
            taskSlug: queueable.taskConfig?.slug,
            workflowSlug: queueable.workflowConfig?.slug,
            onlyScheduled: true,
          })

        // 최대 3개의 동시 예약된 jobs를 허용하고 동적 입력 설정
        return {
          shouldSchedule: runnableOrActiveJobsForQueue < 3,
          input: { text: 'Hi there' },
        }
      },
    },
  },
]
```

이것은 동시에 실행할 수 있는 Jobs 수에 대한 세밀한 제어를 허용하고 Job이 예약될 때마다 동적으로 계산된 입력 값을 제공합니다.

## 서버리스 환경에서의 예약

서버리스 플랫폼에서는 Payload가 임시 환경에서 자동으로 cron 스케줄을 실행하지 않기 때문에 예약을 외부에서 트리거해야 합니다. 예약을 수동으로 트리거하는 두 가지 주요 방법이 있습니다:

- **Payload의 API를 통한 호출:** `payload.jobs.handleSchedules()`
- **REST API 엔드포인트 사용:** `/api/payload-jobs/handle-schedules`
- **기본적으로 예약도 처리하는 run 엔드포인트 사용:** `GET /api/payload-jobs/run`

예를 들어, Vercel에서는 정기적으로 예약을 트리거하는 Vercel Cron을 설정할 수 있습니다:

- **Vercel Cron Job:** Vercel Cron을 구성하여 주기적으로 `GET /api/payload-jobs/handle-schedules`를 호출합니다. 예약된 jobs도 자동 실행하려면 `GET /api/payload-jobs/run` 엔드포인트를 사용할 수 있습니다.

Jobs가 대기열에 추가되면, 그들의 실행은 구성된 runner 설정(예: autorun 또는 수동 호출)에 전적으로 의존합니다.